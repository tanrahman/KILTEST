L 1 "API\CIU98M25_API_Base_NoNVM.c"
N/*****************************************************
N Copyright(C),CEC Huada Electronic Design Co.,Ltd.
N 
N File name: CIU98M25_API_Base_NoNVM.c
N Author:    
N Version:	
N Date:      
N Description:   CIU98M25  User API Function
N History:	
N                V1.0	2014-11-26	initial version
N******************************************************/
N#include "CIU98M25_SFR_C.H"
L 1 ".\INC\CIU98M25_SFR_C.H" 1
N/******************** (C) COPYRIGHT 2014 HED *************************************
N* File Name          : CIU98M25_SFR_C.h
N* Author             : lursh
N* Date First Issued  : 2014-12-1
N* Description        : This file describes the register map of CIU98M25
N// ------------------------------------------------------------
N// Modification History:
N// Version    Date       Author    Modification Description
N// V0.0      2014-12-1   lursh     initial version
N*********************************************************************************/
N
N#ifndef __IO_CIU98M25_H
N#define __IO_CIU98M25_H
N
N/********************************************************************************
N                      AMBA IP AHB Peripherals Addresse
N********************************************************************************/
N/********************************************************************************
N                             CRC Regsiter
N********************************************************************************/
N#define CRCCSR               (*((volatile unsigned long *)(0x50005000 + 0x00 )))
N#define CRCDATA              (*((volatile unsigned long *)(0x50005000 + 0x04 )))
N#define CRCIV                (*((volatile unsigned long *)(0x50005000 + 0x08 )))
N
N/********************************************************************************
N                             SystemController Regsiter
N********************************************************************************/
N// EMMU
N#define SYSEMMUCON           (*((volatile unsigned long *)(0x50007000 + 0x1C )))
N#define SYSCMSBCS            (*((volatile unsigned long *)(0x50007000 + 0x20 )))
N#define SYSNVMDEADDR         (*((volatile unsigned long *)(0x50007000 + 0x28 )))
N#define SYSSWITCHTAG1        (*((volatile unsigned long *)(0x50007000 + 0x30 )))
N#define SYSSWITCHTAG2        (*((volatile unsigned long *)(0x50007000 + 0x34 )))
N#define SYSSWITCHTAG3        (*((volatile unsigned long *)(0x50007000 + 0x38 )))
N
N// NVM
N#define SYSNVMSTATUS         (*((volatile unsigned long *)(0x50007000 + 0x80 )))
N#define SYSNVMMODE           (*((volatile unsigned long *)(0x50007000 + 0x84 )))
N#define SYSNVMCON            (*((volatile unsigned long *)(0x50007000 + 0x88 )))
N#define SYSVERIERRADDR       (*((volatile unsigned long *)(0x50007000 + 0x8C )))
N#define SYSNVMABTADDR        (*((volatile unsigned long *)(0x50007000 + 0x90 )))
N#define SYSNVMSDPK1          (*((volatile unsigned long *)(0x50007000 + 0xA0 )))
N#define SYSNVMSDPK2          (*((volatile unsigned long *)(0x50007000 + 0xA4 )))
N#define SYSNVMSDPK3          (*((volatile unsigned long *)(0x50007000 + 0xA8 )))
N#define SYSECCSTADDR         (*((volatile unsigned long *)(0x50007000 + 0xEC )))
N
N// RSTMU
N#define SYSINFST             (*((volatile unsigned long *)(0x50007000 + 0x180)))
N#define SYSRSTFLAG           (*((volatile unsigned long *)(0x50007000 + 0x184)))
N#define SYSRSTCFG            (*((volatile unsigned long *)(0x50007000 + 0x188)))
N#define SYSINTCLR            (*((volatile unsigned long *)(0x50007000 + 0x190)))
N#define SYSPUDCON            (*((volatile unsigned long *)(0x50007000 + 0x194)))
N#define SYSVDFLAG            (*((volatile unsigned long *)(0x50007000 + 0x198)))
N#define SYSINFCON            (*((volatile unsigned long *)(0x50007000 + 0x19C)))
N
N// CKMU
N#define SYSCLKEN             (*((volatile unsigned long *)(0x50007000 + 0x200)))
N#define SYSCLKCLR            (*((volatile unsigned long *)(0x50007000 + 0x204)))
N#define SYSCLKCFG            (*((volatile unsigned long *)(0x50007000 + 0x208)))
N
N// POWMU
N#define SYSPCON1             (*((volatile unsigned long *)(0x50007000 + 0x280)))
N#define SYSPCON3             (*((volatile unsigned long *)(0x50007000 + 0x288)))
N#define SYSWKPCALIB          (*((volatile unsigned long *)(0x50007000 + 0x28C)))
N#define SYSWKPCON            (*((volatile unsigned long *)(0x50007000 + 0x290)))
N#define SYSVR12PB            (*((volatile unsigned long *)(0x50007000 + 0x294)))
N#define SYSNVMVR12PB         (*((volatile unsigned long *)(0x50007000 + 0x298)))
N#define SYSVR18PB            (*((volatile unsigned long *)(0x50007000 + 0x29C)))
N
N// INTC
N#define SYSIRQLR             (*((volatile unsigned long *)(0x50007000 + 0x380)))
N#define SYSNMICON            (*((volatile unsigned long *)(0x50007000 + 0x384)))
N
N// SEC
N#define SECCTR               (*((volatile unsigned long *)(0x50007000 + 0x400)))
N#define SECMEINIH            (*((volatile unsigned long *)(0x50007000 + 0x404)))
N#define SECMEINIL            (*((volatile unsigned long *)(0x50007000 + 0x408)))
N#define SECPKEMEINI          (*((volatile unsigned long *)(0x50007000 + 0x410)))
N#define SECPKEADMESS         (*((volatile unsigned long *)(0x50007000 + 0x414))) 
N#define SECSWRSTFLG          (*((volatile unsigned long *)(0x50007000 + 0x418)))
N#define SECHWRSTFLG          (*((volatile unsigned long *)(0x50007000 + 0x41C)))
N#define SECBUSY              (*((volatile unsigned long *)(0x50007000 + 0x420)))
N#define SECRBCLR             (*((volatile unsigned long *)(0x50007000 + 0x424)))
N#define SECREGPRT            (*((volatile unsigned long *)(0x50007000 + 0x428)))
N#define SECSWCES             (*((volatile unsigned long *)(0x50007000 + 0x42C)))
N#define SECAUTOCHK           (*((volatile unsigned long *)(0x50007000 + 0x430)))
N#define SECRNDSTOP           (*((volatile unsigned long *)(0x50007000 + 0x434)))
N#define SECTESTPRST          (*((volatile unsigned long *)(0x50007000 + 0x47C)))
N
N/********************************************************************************
N                             WDT Regsiter
N********************************************************************************/
N#define WDTLOAD              (*((volatile unsigned long *)(0x40000000 + 0x00 )))
N#define WDTVALUE             (*((volatile unsigned long *)(0x40000000 + 0x04 )))
N#define WDTCONTROL           (*((volatile unsigned long *)(0x40000000 + 0x08 )))
N#define WDTIS                (*((volatile unsigned long *)(0x40000000 + 0x0C )))
N
N/********************************************************************************
N                             TIMER Regsiter
N********************************************************************************/
N#define TIMER0LOAD           (*((volatile unsigned long *)(0x40000800 + 0x00 )))
N#define TIMER0VALUE          (*((volatile unsigned long *)(0x40000800 + 0x04 )))
N#define TIMER0CONTROL        (*((volatile unsigned long *)(0x40000800 + 0x08 )))
N#define TIMER0IS             (*((volatile unsigned long *)(0x40000800 + 0x0C )))
N#define TIMER1LOAD           (*((volatile unsigned long *)(0x40000800 + 0x20 )))
N#define TIMER1VALUE          (*((volatile unsigned long *)(0x40000800 + 0x24 )))
N#define TIMER1CONTROL        (*((volatile unsigned long *)(0x40000800 + 0x28 )))
N#define TIMER1IS             (*((volatile unsigned long *)(0x40000800 + 0x2C )))
N
N/********************************************************************************
N                             SCI Regsiter
N********************************************************************************/
N#define SCISBUF              (*((volatile unsigned long *)(0x40001000 + 0x00 )))
N#define SCISCON              (*((volatile unsigned long *)(0x40001000 + 0x04 )))
N#define SCISSR               (*((volatile unsigned long *)(0x40001000 + 0x08 )))
N#define SCISCNT              (*((volatile unsigned long *)(0x40001000 + 0x0C )))
N#define SCITXFCR             (*((volatile unsigned long *)(0x40001000 + 0x10 )))
N#define SCIRXFCR             (*((volatile unsigned long *)(0x40001000 + 0x14 )))
N#define SCITA1               (*((volatile unsigned long *)(0x40001000 + 0x18 )))
N#define SCIS60CON            (*((volatile unsigned long *)(0x40001000 + 0x1C )))
N
N/********************************************************************************
N                             SPI Regsiter
N********************************************************************************/
N#define SPICON               (*((volatile unsigned long *)(0x40001800 + 0x00 )))
N#define SPIDLEN              (*((volatile unsigned long *)(0x40001800 + 0x04 )))
N#define SPIST                (*((volatile unsigned long *)(0x40001800 + 0x08 )))
N#define SPIDIV               (*((volatile unsigned long *)(0x40001800 + 0x0C )))
N#define SPIIE                (*((volatile unsigned long *)(0x40001800 + 0x10 )))
N#define SPIIS                (*((volatile unsigned long *)(0x40001800 + 0x14 )))
N#define SPISTR               (*((volatile unsigned long *)(0x40001800 + 0x18 )))
N#define SPIDATA              (*((volatile unsigned long *)(0x40001800 + 0x40 )))
N
N/********************************************************************************
N                             RNG Regsiter
N********************************************************************************/
N#define RNG1XCFG             (*((volatile unsigned long *)(0x40002800 + 0x24 )))
N#define RNG1XCEN             (*((volatile unsigned long *)(0x40002800 + 0x28 )))
N#define RNG1XCSTR            (*((volatile unsigned long *)(0x40002800 + 0x2C )))
N#define RNG1STR              (*((volatile unsigned long *)(0x40002800 + 0x30 )))
N#define RNG1OUT              (*((volatile unsigned long *)(0x40002800 + 0x34 )))
N#define RTCNT0               (*((volatile unsigned long *)(0x40002800 + 0x38 )))
N#define RTCNT1               (*((volatile unsigned long *)(0x40002800 + 0x3C )))
N#define RTCNT2               (*((volatile unsigned long *)(0x40002800 + 0x40 )))
N#define RTCNT3               (*((volatile unsigned long *)(0x40002800 + 0x44 )))
N#define RTCNT4               (*((volatile unsigned long *)(0x40002800 + 0x48 )))
N#define RTCNT5               (*((volatile unsigned long *)(0x40002800 + 0x4C )))
N#define RTCNT6               (*((volatile unsigned long *)(0x40002800 + 0x50 )))
N#define RTCNT7               (*((volatile unsigned long *)(0x40002800 + 0x54 )))
N#define RTCNT8               (*((volatile unsigned long *)(0x40002800 + 0x58 )))
N#define RTCNT9               (*((volatile unsigned long *)(0x40002800 + 0x5C )))
N#define RTCNT10              (*((volatile unsigned long *)(0x40002800 + 0x60 )))
N#define RTCNT11              (*((volatile unsigned long *)(0x40002800 + 0x64 )))
N#define RTCNT12              (*((volatile unsigned long *)(0x40002800 + 0x68 )))
N#define RTCNT13              (*((volatile unsigned long *)(0x40002800 + 0x6C )))
N#define RTCNT14              (*((volatile unsigned long *)(0x40002800 + 0x70 )))
N#define RTCNT15              (*((volatile unsigned long *)(0x40002800 + 0x74 )))
N
N/********************************************************************************
N                             GPIO Regsiter
N********************************************************************************/
N#define GPIODATA             (*((volatile unsigned long *)(0x40003000 + 0x00 )))
N#define GPIODIR              (*((volatile unsigned long *)(0x40003000 + 0x04 )))
N#define GPIOIS               (*((volatile unsigned long *)(0x40003000 + 0x08 )))
N#define GPIOIBE              (*((volatile unsigned long *)(0x40003000 + 0x0c )))
N#define GPIOIEV              (*((volatile unsigned long *)(0x40003000 + 0x10 )))
N#define GPIOIE               (*((volatile unsigned long *)(0x40003000 + 0x14 )))
N#define GPIORIS              (*((volatile unsigned long *)(0x40003000 + 0x18 )))
N#define GPIOMIS              (*((volatile unsigned long *)(0x40003000 + 0x1c )))
N#define GPIOIC               (*((volatile unsigned long *)(0x40003000 + 0x20 )))
N
N/********************************************************************************
N                             SWP Regsiter
N********************************************************************************/
N#define SWPIT                (*((volatile unsigned long *)(0x40003800 + 0x00 )))
N#define SWPITMK              (*((volatile unsigned long *)(0x40003800 + 0x04 )))
N#define SWPITEN              (*((volatile unsigned long *)(0x40003800 + 0x08 )))
N#define SWPITENCLR           (*((volatile unsigned long *)(0x40003800 + 0x0C )))
N#define SWPCON               (*((volatile unsigned long *)(0x40003800 + 0x10 )))
N#define SWPCLT               (*((volatile unsigned long *)(0x40003800 + 0x14 )))
N#define SWPTFS               (*((volatile unsigned long *)(0x40003800 + 0x18 )))
N#define SWPRFS               (*((volatile unsigned long *)(0x40003800 + 0x1C )))
N#define SWPBFC               (*((volatile unsigned long *)(0x40003800 + 0x20 )))
N#define SWPBFS               (*((volatile unsigned long *)(0x40003800 + 0x24 )))
N#define SWPMTP               (*((volatile unsigned long *)(0x40003800 + 0x30 )))
N#define SWPMTC               (*((volatile unsigned long *)(0x40003800 + 0x34 )))
N#define SWPMOD               (*((volatile unsigned long *)(0x40003800 + 0x80 )))
N#define SWPPARA1             (*((volatile unsigned long *)(0x40003800 + 0x100 )))
N#define SWPPARA2             (*((volatile unsigned long *)(0x40003800 + 0x104 )))
N#define SWPPARA5             (*((volatile unsigned long *)(0x40003800 + 0x108 )))
N#define SWPSID               (*((volatile unsigned long *)(0x40003800 + 0x10C )))
N#define SWPSSR               (*((volatile unsigned long *)(0x40003800 + 0x180 )))
N#define SWPSTATE             (*((volatile unsigned long *)(0x40003800 + 0x184 )))
N#define SWPM1KL              (*((volatile unsigned long *)(0x40003800 + 0x1C0 )))
N#define SWPM1KM              (*((volatile unsigned long *)(0x40003800 + 0x1C4 )))
N#define SWPM1KH              (*((volatile unsigned long *)(0x40003800 + 0x1C8 )))
N#define SWPM1RNG             (*((volatile unsigned long *)(0x40003800 + 0x1CC )))
N#define SWPUID               (*((volatile unsigned long *)(0x40003800 + 0x1D0 )))
N#define SWPDBUF              (*((volatile unsigned long *)(0x40003800 + 0x300 )))
N#define SWPSDBUF             ((volatile unsigned long *)(0x40003800 + 0x304 ))
N
N/********************************************************************************
N                             PPB Regsiter
N********************************************************************************/
N
N#define ACTLR                 (*((volatile unsigned long *)( 0xE000E008	)))
N#define NVIC_ISER             (*((volatile unsigned long *)( 0xE000E100	)))
N#define NVIC_ICER             (*((volatile unsigned long *)( 0xE000E180	)))
N#define NVIC_ISPR             (*((volatile unsigned long *)( 0xE000E200	)))
N#define NVIC_ICPR             (*((volatile unsigned long *)( 0xE000E280	)))
N#define NVIC_IPR0             (*((volatile unsigned long *)( 0xE000E400	)))
N#define NVIC_IPR1             (*((volatile unsigned long *)( 0xE000E404	)))
N#define NVIC_IPR2             (*((volatile unsigned long *)( 0xE000E408	)))
N#define NVIC_IPR3             (*((volatile unsigned long *)( 0xE000E40C	)))
N#define NVIC_IPR4             (*((volatile unsigned long *)( 0xE000E410	)))
N#define NVIC_IPR5             (*((volatile unsigned long *)( 0xE000E414	)))
N#define NVIC_IPR6             (*((volatile unsigned long *)( 0xE000E418	)))
N#define NVIC_IPR7             (*((volatile unsigned long *)( 0xE000E41C	)))
N#define CPUID                 (*((volatile unsigned long *)( 0xE000ED00	)))
N#define ICSR                  (*((volatile unsigned long *)( 0xE000ED04	)))
N#define VTOR                  (*((volatile unsigned long *)( 0xE000ED08	)))
N#define AIRCR                 (*((volatile unsigned long *)( 0xE000ED0C	)))
N#define SCR                   (*((volatile unsigned long *)( 0xE000ED10	)))
N#define CCR                   (*((volatile unsigned long *)( 0xE000ED14	)))
N#define SHPR2                 (*((volatile unsigned long *)( 0xE000ED1C	)))
N#define SHPR3                 (*((volatile unsigned long *)( 0xE000ED20	)))
N#define MPU_TYPE              (*((volatile unsigned long *)( 0xE000ED90	)))
N#define MPU_CTRL              (*((volatile unsigned long *)( 0xE000ED94	)))
N#define MPU_RNR               (*((volatile unsigned long *)( 0xE000ED98	)))
N#define MPU_RBAR              (*((volatile unsigned long *)( 0xE000ED9C	)))
N#define MPU_RASR              (*((volatile unsigned long *)( 0xE000EDA0	)))
N#define SFCR                  (*((volatile unsigned long *)( 0xE000EF90	)))
N
N/********************************************************************************
N                             Interrupt Source
N********************************************************************************/
N#define     IRQ_TMR0                0
N#define     IRQ_TMR1                1
N#define     IRQ_WDT                 2
N#define     IRQ_NVMCTR              3
N#define     IRQ_NVMDE               4
N#define     IRQ_SECRST              5
N#define     IRQ_RNG1                7
N#define     IRQ_7816RST             8
N#define     IRQ_7816TX              9
N#define     IRQ_7816RX              10
N#define     IRQ_7816FIFO            11
N#define     IRQ_IFDET               12
N#define     IRQ_SWP                 13
N#define     IRQ_SPI                 14
N#define     IRQ_GPIOINT0            15
N
N#endif  /* End of __IO_CIU98M25_H */
L 13 "API\CIU98M25_API_Base_NoNVM.c" 2
N#include <stdlib.h>
L 1 "C:\Keil_v4\ARM\ARMCC\bin\..\include\stdlib.h" 1
N/* stdlib.h: ANSI draft (X3J11 May 88) library header, section 4.10 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                          */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.            */
N/*
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N * Revising $Author: agrant $
N */
N 
N/*
N * stdlib.h declares four types, several general purpose functions,
N * and defines several macros.
N */
N
N#ifndef __stdlib_h
N#define __stdlib_h
N#define __ARMCLIB_VERSION 5030076
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __pure
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define _ARMABI_THROW
N
N  #ifndef __STDLIB_DECLS
N  #define __STDLIB_DECLS
N
N  /*
N   * Some of these declarations are new in C99.  To access them in C++
N   * you can use -D__USE_C99_STDLIB (or -D__USE_C99ALL).
N   */
N  #ifndef __USE_C99_STDLIB
N    #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X    #if 0L || (1L && 199901L <= 199409L)
S      #define __USE_C99_STDLIB 1
N    #endif
N  #endif
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;
N#elif !defined(__size_t)
S  #define __size_t 1
S  typedef unsigned int size_t;   /* see <stddef.h> */
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N   /* unconditional in non-strict C for consistency of debug info */
N   #if defined(__WCHAR32)
X   #if 0L
S    typedef unsigned int wchar_t; /* see <stddef.h> */
N   #else
N    typedef unsigned short wchar_t; /* see <stddef.h> */
N   #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S   #if defined(__WCHAR32)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
S   #else
S    typedef unsigned short wchar_t; /* see <stddef.h> */
S   #endif
N  #endif
N#endif
N
Ntypedef struct div_t { int quot, rem; } div_t;
N   /* type of the value returned by the div function. */
Ntypedef struct ldiv_t { long int quot, rem; } ldiv_t;
N   /* type of the value returned by the ldiv function. */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Ntypedef struct lldiv_t { __int64 quot, rem; } lldiv_t;
N   /* type of the value returned by the lldiv function. */
N#endif
N
N#ifdef __EXIT_FAILURE
S#  define EXIT_FAILURE __EXIT_FAILURE
S   /*
S    * an integral expression which may be used as an argument to the exit
S    * function to return unsuccessful termination status to the host
S    * environment.
S    */
N#else
N#  define EXIT_FAILURE 1  /* unixoid */
N#endif
N#define EXIT_SUCCESS 0
N   /*
N    * an integral expression which may be used as an argument to the exit
N    * function to return successful termination status to the host
N    * environment.
N    */
N
N   /*
N    * Defining __USE_ANSI_EXAMPLE_RAND at compile time switches to
N    * the example implementation of rand() and srand() provided in
N    * the ANSI C standard. This implementation is very poor, but is
N    * provided for completeness.
N    */
N#ifdef __USE_ANSI_EXAMPLE_RAND
S#define srand _ANSI_srand
S#define rand _ANSI_rand
S#define RAND_MAX 0x7fff
N#else
N#define RAND_MAX 0x7fffffff
N#endif
N   /*
N    * RAND_MAX: an integral constant expression, the value of which
N    * is the maximum value returned by the rand function.
N    */
Nextern _ARMABI int __aeabi_MB_CUR_MAX(void);
Xextern __declspec(__nothrow) int __aeabi_MB_CUR_MAX(void);
N#define MB_CUR_MAX ( __aeabi_MB_CUR_MAX() )
N   /*
N    * a positive integer expression whose value is the maximum number of bytes
N    * in a multibyte character for the extended character set specified by the
N    * current locale (category LC_CTYPE), and whose value is never greater
N    * than MB_LEN_MAX.
N    */
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain a compliant version of the strtod
N    * family of functions.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Nextern _ARMABI double atof(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double atof(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI int atoi(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atoi(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to int
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI long int atol(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int atol(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation.
N    * Returns: the converted value.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI __int64 atoll(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) __int64 atoll(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to
N    * long long int representation.
N    * Returns: the converted value.
N    */
N#endif
N
Nextern _ARMABI double strtod(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double strtod(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling a
N    * floating point constant; and a final string of one or more unrecognised
N    * characters, including the terminating null character of the input string.
N    * Then it attempts to convert the subject sequence to a floating point
N    * number, and returns the result. A pointer to the final string is stored
N    * in the object pointed to by endptr, provided that endptr is not a null
N    * pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned. If the correct value is outside the range of
N    *          representable values, plus or minus HUGE_VAL is returned
N    *          (according to the sign of the value), and the value of the macro
N    *          ERANGE is stored in errno. If the correct value would cause
N    *          underflow, zero is returned and the value of the macro ERANGE is
N    *          stored in errno.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI float strtof(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) float strtof(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
Nextern _ARMABI long double strtold(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long double strtold(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * same as strtod, but return float and long double respectively.
N    */
N#endif
Nextern _ARMABI long int strtol(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long int strtol(const char * __restrict  ,
N                        char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling an
N    * integer represented in some radix determined by the value of base, and a
N    * final string of one or more unrecognised characters, including the
N    * terminating null character of the input string. Then it attempts to
N    * convert the subject sequence to an integer, and returns the result.
N    * If the value of base is 0, the expected form of the subject sequence is
N    * that of an integer constant (described in ANSI Draft, section 3.1.3.2),
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. If the value of base is between 2 and 36, the expected form of
N    * the subject sequence is a sequence of letters and digits representing an
N    * integer with the radix specified by base, optionally preceded by a plus
N    * or minus sign, but not including an integer suffix. The letters from a
N    * (or A) through z (or Z) are ascribed the values 10 to 35; only letters
N    * whose ascribed values are less than that of the base are permitted. If
N    * the value of base is 16, the characters 0x or 0X may optionally precede
N    * the sequence of letters and digits following the sign if present.
N    * A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, LONG_MAX or LONG_MIN is returned
N    *          (according to the sign of the value), and the value of the
N    *          macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned long int strtoul(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long int strtoul(const char * __restrict  ,
N                                       char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to unsigned
N    * long int representation. First it decomposes the input string into three
N    * parts: an initial, possibly empty, sequence of white-space characters (as
N    * determined by the isspace function), a subject sequence resembling an
N    * unsigned integer represented in some radix determined by the value of
N    * base, and a final string of one or more unrecognised characters,
N    * including the terminating null character of the input string. Then it
N    * attempts to convert the subject sequence to an unsigned integer, and
N    * returns the result. If the value of base is zero, the expected form of
N    * the subject sequence is that of an integer constant (described in ANSI
N    * Draft, section 3.1.3.2), optionally preceded by a '+' or '-' sign, but
N    * not including an integer suffix. If the value of base is between 2 and
N    * 36, the expected form of the subject sequence is a sequence of letters
N    * and digits representing an integer with the radix specified by base,
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. The letters from a (or A) through z (or Z) stand for the values
N    * 10 to 35; only letters whose ascribed values are less than that of the
N    * base are permitted. If the value of base is 16, the characters 0x or 0X
N    * may optionally precede the sequence of letters and digits following the
N    * sign, if present. A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, ULONG_MAX is returned, and the value of
N    *          the macro ERANGE is stored in errno.
N    */
N
N/* C90 reserves all names beginning with 'str' */
Nextern _ARMABI __int64 strtoll(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) __int64 strtoll(const char * __restrict  ,
N                               char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * as strtol but returns a long long int value.  If the correct value is
N    * outside the range of representable values,  LLONG_MAX or LLONG_MIN is
N    * returned (according to the sign of the value), and the value of the
N    * macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned __int64 strtoull(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned __int64 strtoull(const char * __restrict  ,
N                                         char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * as strtoul but returns an unsigned long long int value.  If the correct
N    * value is outside the range of representable values, ULLONG_MAX is returned,
N    * and the value of the macro ERANGE is stored in errno.
N    */
N
Nextern _ARMABI int rand(void);
Xextern __declspec(__nothrow) int rand(void);
N   /*
N    * Computes a sequence of pseudo-random integers in the range 0 to RAND_MAX.
N    * Uses an additive generator (Mitchell & Moore) of the form:
N    *   Xn = (X[n-24] + X[n-55]) MOD 2^31
N    * This is described in section 3.2.2 of Knuth, vol 2. It's period is
N    * in excess of 2^55 and its randomness properties, though unproven, are
N    * conjectured to be good. Empirical testing since 1958 has shown no flaws.
N    * Returns: a pseudo-random integer.
N    */
Nextern _ARMABI void srand(unsigned int /*seed*/);
Xextern __declspec(__nothrow) void srand(unsigned int  );
N   /*
N    * uses its argument as a seed for a new sequence of pseudo-random numbers
N    * to be returned by subsequent calls to rand. If srand is then called with
N    * the same seed value, the sequence of pseudo-random numbers is repeated.
N    * If rand is called before any calls to srand have been made, the same
N    * sequence is generated as when srand is first called with a seed value
N    * of 1.
N    */
N
Nstruct _rand_state { int __x[57]; };
Nextern _ARMABI int _rand_r(struct _rand_state *);
Xextern __declspec(__nothrow) int _rand_r(struct _rand_state *);
Nextern _ARMABI void _srand_r(struct _rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _srand_r(struct _rand_state *, unsigned int);
Nstruct _ANSI_rand_state { int __x[1]; };
Nextern _ARMABI int _ANSI_rand_r(struct _ANSI_rand_state *);
Xextern __declspec(__nothrow) int _ANSI_rand_r(struct _ANSI_rand_state *);
Nextern _ARMABI void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
N   /*
N    * Re-entrant variants of both flavours of rand, which operate on
N    * an explicitly supplied state buffer.
N    */
N
Nextern _ARMABI void *calloc(size_t /*nmemb*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *calloc(size_t  , size_t  );
N   /*
N    * allocates space for an array of nmemb objects, each of whose size is
N    * 'size'. The space is initialised to all bits zero.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void free(void * /*ptr*/);
Xextern __declspec(__nothrow) void free(void *  );
N   /*
N    * causes the space pointed to by ptr to be deallocated (i.e., made
N    * available for further allocation). If ptr is a null pointer, no action
N    * occurs. Otherwise, if ptr does not match a pointer earlier returned by
N    * calloc, malloc or realloc or if the space has been deallocated by a call
N    * to free or realloc, the behaviour is undefined.
N    */
Nextern _ARMABI void *malloc(size_t /*size*/);
Xextern __declspec(__nothrow) void *malloc(size_t  );
N   /*
N    * allocates space for an object whose size is specified by 'size' and whose
N    * value is indeterminate.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void *realloc(void * /*ptr*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *realloc(void *  , size_t  );
N   /*
N    * changes the size of the object pointed to by ptr to the size specified by
N    * size. The contents of the object shall be unchanged up to the lesser of
N    * the new and old sizes. If the new size is larger, the value of the newly
N    * allocated portion of the object is indeterminate. If ptr is a null
N    * pointer, the realloc function behaves like a call to malloc for the
N    * specified size. Otherwise, if ptr does not match a pointer earlier
N    * returned by calloc, malloc or realloc, or if the space has been
N    * deallocated by a call to free or realloc, the behaviour is undefined.
N    * If the space cannot be allocated, the object pointed to by ptr is
N    * unchanged. If size is zero and ptr is not a null pointer, the object it
N    * points to is freed.
N    * Returns: either a null pointer or a pointer to the possibly moved
N    *          allocated space.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
Nextern _ARMABI int posix_memalign(void ** /*ret*/, size_t /*alignment*/, size_t /*size*/);
Xextern __declspec(__nothrow) int posix_memalign(void **  , size_t  , size_t  );
N   /*
N    * allocates space for an object of size 'size', aligned to a
N    * multiple of 'alignment' (which must be a power of two and at
N    * least 4).
N    *
N    * On success, a pointer to the allocated object is stored in
N    * *ret, and zero is returned. On failure, the return value is
N    * either ENOMEM (allocation failed because no suitable piece of
N    * memory was available) or EINVAL (the 'alignment' parameter was
N    * invalid).
N    */
N#endif
Ntypedef int (*__heapprt)(void *, char const *, ...);
Nextern _ARMABI void __heapstats(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) void __heapstats(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                        void * /*param*/) __attribute__((__nonnull__(1)));
N   /*
N    * reports current heap statistics (eg. number of free blocks in
N    * the free-list). Output is as implementation-defined free-form
N    * text, provided via the dprint function. `param' gives an
N    * extra data word to pass to dprint. You can call
N    * __heapstats(fprintf,stdout) by casting fprintf to the above
N    * function type; the typedef `__heapprt' is provided for this
N    * purpose.
N    *
N    * `dprint' will not be called while the heap is being examined,
N    * so it can allocate memory itself without trouble.
N    */
Nextern _ARMABI int __heapvalid(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) int __heapvalid(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                       void * /*param*/, int /*verbose*/) __attribute__((__nonnull__(1)));
N   /*
N    * performs a consistency check on the heap. Errors are reported
N    * through dprint, like __heapstats. If `verbose' is nonzero,
N    * full diagnostic information on the heap state is printed out.
N    *
N    * This routine probably won't work if the heap isn't a
N    * contiguous chunk (for example, if __user_heap_extend has been
N    * overridden).
N    *
N    * `dprint' may be called while the heap is being examined or
N    * even in an invalid state, so it must perform no memory
N    * allocation. In particular, if `dprint' calls (or is) a stdio
N    * function, the stream it outputs to must already have either
N    * been written to or been setvbuf'ed, or else the system will
N    * allocate buffer space for it on the first call to dprint.
N    */
Nextern _ARMABI_NORETURN void abort(void);
Xextern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N   /*
N    * causes abnormal program termination to occur, unless the signal SIGABRT
N    * is being caught and the signal handler does not return. Whether open
N    * output streams are flushed or open streams are closed or temporary
N    * files removed is implementation-defined.
N    * An implementation-defined form of the status 'unsuccessful termination'
N    * is returned to the host environment by means of a call to
N    * raise(SIGABRT).
N    */
N
Nextern _ARMABI int atexit(void (* /*func*/)(void)) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atexit(void (*  )(void)) __attribute__((__nonnull__(1)));
N   /*
N    * registers the function pointed to by func, to be called without its
N    * arguments at normal program termination. It is possible to register at
N    * least 32 functions.
N    * Returns: zero if the registration succeeds, nonzero if it fails.
N    */
N#if defined(__cplusplus) && !defined(__GNUC__)
X#if 0L && !0L
S    /* atexit that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode  
S     */
S    typedef void (* __C_exitfuncptr)();
S    extern "C++"
S    inline int atexit(void (* __func)()) {
S      return atexit((__C_exitfuncptr)__func);
S    }
N#endif
N
N
Nextern _ARMABI_NORETURN void exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void exit(int  );
N   /*
N    * causes normal program termination to occur. If more than one call to the
N    * exit function is executed by a program, the behaviour is undefined.
N    * First, all functions registered by the atexit function are called, in the
N    * reverse order of their registration.
N    * Next, all open output streams are flushed, all open streams are closed,
N    * and all files created by the tmpfile function are removed.
N    * Finally, control is returned to the host environment. If the value of
N    * status is zero or EXIT_SUCCESS, an implementation-defined form of the
N    * status 'successful termination' is returned. If the value of status is
N    * EXIT_FAILURE, an implementation-defined form of the status
N    * 'unsuccessful termination' is returned. Otherwise the status returned
N    * is implementation-defined.
N    */
N
Nextern _ARMABI_NORETURN void _Exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void _Exit(int  );
N   /*
N    * causes normal program termination to occur. No functions registered
N    * by the atexit function are called.
N    * In this implementation, all open output streams are flushed, all
N    * open streams are closed, and all files created by the tmpfile function
N    * are removed.
N    * Control is returned to the host environment. The status returned to
N    * the host environment is determined in the same way as for 'exit'.
N    */     
N
Nextern _ARMABI char *getenv(const char * /*name*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *getenv(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * searches the environment list, provided by the host environment, for a
N    * string that matches the string pointed to by name. The set of environment
N    * names and the method for altering the environment list are
N    * implementation-defined.
N    * Returns: a pointer to a string associated with the matched list member.
N    *          The array pointed to shall not be modified by the program, but
N    *          may be overwritten by a subsequent call to the getenv function.
N    *          If the specified name cannot be found, a null pointer is
N    *          returned.
N    */
N
Nextern _ARMABI int  system(const char * /*string*/);
Xextern __declspec(__nothrow) int  system(const char *  );
N   /*
N    * passes the string pointed to by string to the host environment to be
N    * executed by a command processor in an implementation-defined manner.
N    * A null pointer may be used for string, to inquire whether a command
N    * processor exists.
N    *
N    * Returns: If the argument is a null pointer, the system function returns
N    *          non-zero only if a command processor is available. If the
N    *          argument is not a null pointer, the system function returns an
N    *          implementation-defined value.
N    */
N
Nextern _ARMABI_THROW void *bsearch(const void * /*key*/, const void * /*base*/,
Xextern  void *bsearch(const void *  , const void *  ,
N              size_t /*nmemb*/, size_t /*size*/,
N              int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
N   /*
N    * searches an array of nmemb objects, the initial member of which is
N    * pointed to by base, for a member that matches the object pointed to by
N    * key. The size of each member of the array is specified by size.
N    * The contents of the array shall be in ascending sorted order according to
N    * a comparison function pointed to by compar, which is called with two
N    * arguments that point to the key object and to an array member, in that
N    * order. The function shall return an integer less than, equal to, or
N    * greater than zero if the key object is considered, respectively, to be
N    * less than, to match, or to be greater than the array member.
N    * Returns: a pointer to a matching member of the array, or a null pointer
N    *          if no match is found. If two members compare as equal, which
N    *          member is matched is unspecified.
N    */
N#if defined(__cplusplus) && !defined(__GNUC__)
X#if 0L && !0L
S    /* bsearch that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */
S    typedef int (* __C_compareprocptr)(const void *, const void *);
S    extern "C++"
S    void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
S    extern "C++"
S    inline void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) {
S      return bsearch(__key, __base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
N
Nextern _ARMABI_THROW void qsort(void * /*base*/, size_t /*nmemb*/, size_t /*size*/,
Xextern  void qsort(void *  , size_t  , size_t  ,
N           int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
N   /*
N    * sorts an array of nmemb objects, the initial member of which is pointed
N    * to by base. The size of each object is specified by size.
N    * The contents of the array shall be in ascending order according to a
N    * comparison function pointed to by compar, which is called with two
N    * arguments that point to the objects being compared. The function shall
N    * return an integer less than, equal to, or greater than zero if the first
N    * argument is considered to be respectively less than, equal to, or greater
N    * than the second. If two members compare as equal, their order in the
N    * sorted array is unspecified.
N    */
N
N#if defined(__cplusplus) && !defined(__GNUC__)
X#if 0L && !0L
S    /* qsort that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */    
S    extern "C++"
S    void qsort(void * __base, size_t __nmemb, size_t __size,
S               int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
S    extern "C++"
S    inline void qsort(void * __base, size_t __nmemb, size_t __size,
S                      int (* __compar)(const void *, const void *)) {
S      qsort(__base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
Nextern _ARMABI_PURE int abs(int /*j*/);
Xextern __declspec(__nothrow) __pure int abs(int  );
N   /*
N    * computes the absolute value of an integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N
Nextern _ARMABI_PURE div_t div(int /*numer*/, int /*denom*/);
Xextern __declspec(__nothrow) __pure div_t div(int  , int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the resulting
N    * quotient is the integer of lesser magnitude that is the nearest to the
N    * algebraic quotient. If the result cannot be represented, the behaviour is
N    * undefined; otherwise, quot * denom + rem shall equal numer.
N    * Returns: a structure of type div_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          int quot; int rem;
N    */
Nextern _ARMABI_PURE long int labs(long int /*j*/);
Xextern __declspec(__nothrow) __pure long int labs(long int  );
N   /*
N    * computes the absolute value of an long integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE long abs(long int x) { return labs(x); }
N#endif
N
Nextern _ARMABI_PURE ldiv_t ldiv(long int /*numer*/, long int /*denom*/);
Xextern __declspec(__nothrow) __pure ldiv_t ldiv(long int  , long int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type ldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long int quot; long int rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE ldiv_t div(long int __numer, long int __denom) {
S       return ldiv(__numer, __denom);
S   }
N#endif
N
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI_PURE __int64 llabs(__int64 /*j*/);
Xextern __declspec(__nothrow) __pure __int64 llabs(__int64  );
N   /*
N    * computes the absolute value of a __int64 integer j. If the
N    * result cannot be represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE __int64 abs(__int64 x) { return llabs(x); }
N#endif
N
Nextern _ARMABI_PURE lldiv_t lldiv(__int64 /*numer*/, __int64 /*denom*/);
Xextern __declspec(__nothrow) __pure lldiv_t lldiv(__int64  , __int64  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type lldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long long quot; long long rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE lldiv_t div(__int64 __numer, __int64 __denom) {
S       return lldiv(__numer, __denom);
S   }
N#endif
N#endif
N
N/*
N * ARM real-time divide functions for guaranteed performance
N */
Ntypedef struct __sdiv32by16 { int quot, rem; } __sdiv32by16;
Ntypedef struct __udiv32by16 { unsigned int quot, rem; } __udiv32by16;
N   /* used int so that values return in separate regs, although 16-bit */
Ntypedef struct __sdiv64by32 { int rem, quot; } __sdiv64by32;
N
N__value_in_regs extern _ARMABI_PURE __sdiv32by16 __rt_sdiv32by16(
X__value_in_regs extern __declspec(__nothrow) __pure __sdiv32by16 __rt_sdiv32by16(
N     int /*numer*/,
N     short int /*denom*/);
N   /*
N    * Signed divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __udiv32by16 __rt_udiv32by16(
X__value_in_regs extern __declspec(__nothrow) __pure __udiv32by16 __rt_udiv32by16(
N     unsigned int /*numer*/,
N     unsigned short /*denom*/);
N   /*
N    * Unsigned divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __sdiv64by32 __rt_sdiv64by32(
X__value_in_regs extern __declspec(__nothrow) __pure __sdiv64by32 __rt_sdiv64by32(
N     int /*numer_h*/, unsigned int /*numer_l*/,
N     int /*denom*/);
N   /*
N    * Signed divide: (32-bit quot), (32-bit rem) = (64-bit) / (32-bit)
N    */
N
N/*
N * ARM floating-point mask/status function (for both hardfp and softfp)
N */
Nextern _ARMABI unsigned int __fp_status(unsigned int /*mask*/, unsigned int /*flags*/);
Xextern __declspec(__nothrow) unsigned int __fp_status(unsigned int  , unsigned int  );
N   /*
N    * mask and flags are bit-fields which correspond directly to the
N    * floating point status register in the FPE/FPA and fplib.  
N    * __fp_status returns the current value of the status register,
N    * and also sets the writable bits of the word
N    * (the exception control and flag bytes) to:
N    *
N    *     new = (old & ~mask) ^ flags;
N    */
N#define __fpsr_IXE  0x100000
N#define __fpsr_UFE  0x80000
N#define __fpsr_OFE  0x40000
N#define __fpsr_DZE  0x20000
N#define __fpsr_IOE  0x10000
N
N#define __fpsr_IXC  0x10
N#define __fpsr_UFC  0x8
N#define __fpsr_OFC  0x4
N#define __fpsr_DZC  0x2
N#define __fpsr_IOC  0x1
N
N/*
N * Multibyte Character Functions.
N * The behaviour of the multibyte character functions is affected by the
N * LC_CTYPE category of the current locale. For a state-dependent encoding,
N * each function is placed into its initial state by a call for which its
N * character pointer argument, s, is a null pointer. Subsequent calls with s
N * as other than a null pointer cause the internal state of the function to be
N * altered as necessary. A call with s as a null pointer causes these functions
N * to return a nonzero value if encodings have state dependency, and a zero
N * otherwise. After the LC_CTYPE category is changed, the shift state of these
N * functions is indeterminate.
N */
Nextern _ARMABI int mblen(const char * /*s*/, size_t /*n*/);
Xextern __declspec(__nothrow) int mblen(const char *  , size_t  );
N   /*
N    * If s is not a null pointer, the mblen function determines the number of
N    * bytes compromising the multibyte character pointed to by s. Except that
N    * the shift state of the mbtowc function is not affected, it is equivalent
N    * to   mbtowc((wchar_t *)0, s, n);
N    * Returns: If s is a null pointer, the mblen function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mblen function either returns a 0 (if s points to a
N    *          null character), or returns the number of bytes that compromise
N    *          the multibyte character (if the next n of fewer bytes form a
N    *          valid multibyte character), or returns -1 (they do not form a
N    *          valid multibyte character).
N    */
Nextern _ARMABI int mbtowc(wchar_t * __restrict /*pwc*/,
Xextern __declspec(__nothrow) int mbtowc(wchar_t * __restrict  ,
N                   const char * __restrict /*s*/, size_t /*n*/);
N   /*
N    * If s is not a null pointer, the mbtowc function determines the number of
N    * bytes that compromise the multibyte character pointed to by s. It then
N    * determines the code for value of type wchar_t that corresponds to that
N    * multibyte character. (The value of the code corresponding to the null
N    * character is zero). If the multibyte character is valid and pwc is not a
N    * null pointer, the mbtowc function stores the code in the object pointed
N    * to by pwc. At most n bytes of the array pointed to by s will be examined.
N    * Returns: If s is a null pointer, the mbtowc function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mbtowc function either returns a 0 (if s points to
N    *          a null character), or returns the number of bytes that
N    *          compromise the converted multibyte character (if the next n of
N    *          fewer bytes form a valid multibyte character), or returns -1
N    *          (they do not form a valid multibyte character).
N    */
Nextern _ARMABI int wctomb(char * /*s*/, wchar_t /*wchar*/);
Xextern __declspec(__nothrow) int wctomb(char *  , wchar_t  );
N   /*
N    * determines the number of bytes need to represent the multibyte character
N    * corresponding to the code whose value is wchar (including any change in
N    * shift state). It stores the multibyte character representation in the
N    * array object pointed to by s (if s is not a null pointer). At most
N    * MB_CUR_MAX characters are stored. If the value of wchar is zero, the
N    * wctomb function is left in the initial shift state).
N    * Returns: If s is a null pointer, the wctomb function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the wctomb function returns a -1 if the value of wchar
N    *          does not correspond to a valid multibyte character, or returns
N    *          the number of bytes that compromise the multibyte character
N    *          corresponding to the value of wchar.
N    */
N
N/*
N * Multibyte String Functions.
N * The behaviour of the multibyte string functions is affected by the LC_CTYPE
N * category of the current locale.
N */
Nextern _ARMABI size_t mbstowcs(wchar_t * __restrict /*pwcs*/,
Xextern __declspec(__nothrow) size_t mbstowcs(wchar_t * __restrict  ,
N                      const char * __restrict /*s*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of multibyte character that begins in the initial
N    * shift state from the array pointed to by s into a sequence of
N    * corresponding codes and stores not more than n codes into the array
N    * pointed to by pwcs. No multibyte character that follow a null character
N    * (which is converted into a code with value zero) will be examined or
N    * converted. Each multibyte character is converted as if by a call to
N    * mbtowc function, except that the shift state of the mbtowc function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by pwcs. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If an invalid multibyte character is encountered, the mbstowcs
N    *          function returns (size_t)-1. Otherwise, the mbstowcs function
N    *          returns the number of array elements modified, not including
N    *          a terminating zero code, if any.
N    */
Nextern _ARMABI size_t wcstombs(char * __restrict /*s*/,
Xextern __declspec(__nothrow) size_t wcstombs(char * __restrict  ,
N                      const wchar_t * __restrict /*pwcs*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of codes that correspond to multibyte characters
N    * from the array pointed to by pwcs into a sequence of multibyte
N    * characters that begins in the initial shift state and stores these
N    * multibyte characters into the array pointed to by s, stopping if a
N    * multibyte character would exceed the limit of n total bytes or if a
N    * null character is stored. Each code is converted as if by a call to the
N    * wctomb function, except that the shift state of the wctomb function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by s. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If a code is encountered that does not correspond to a valid
N    *          multibyte character, the wcstombs function returns (size_t)-1.
N    *          Otherwise, the wcstombs function returns the number of bytes
N    *          modified, not including a terminating null character, if any.
N    */
N
Nextern _ARMABI void __use_realtime_heap(void);
Xextern __declspec(__nothrow) void __use_realtime_heap(void);
Nextern _ARMABI void __use_realtime_division(void);
Xextern __declspec(__nothrow) void __use_realtime_division(void);
Nextern _ARMABI void __use_two_region_memory(void);
Xextern __declspec(__nothrow) void __use_two_region_memory(void);
Nextern _ARMABI void __use_no_heap(void);
Xextern __declspec(__nothrow) void __use_no_heap(void);
Nextern _ARMABI void __use_no_heap_region(void);
Xextern __declspec(__nothrow) void __use_no_heap_region(void);
N
Nextern _ARMABI char const *__C_library_version_string(void);
Xextern __declspec(__nothrow) char const *__C_library_version_string(void);
Nextern _ARMABI int __C_library_version_number(void);
Xextern __declspec(__nothrow) int __C_library_version_number(void);
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDLIB_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
S    #ifndef __STDLIB_NO_EXPORTS
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::atoll;
S        using ::std::lldiv_t;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::div_t;
S      using ::std::ldiv_t;
S      using ::std::atof;
S      using ::std::atoi;
S      using ::std::atol;
S      using ::std::strtod;
S#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S      using ::std::strtof;
S      using ::std::strtold;
S#endif
S      using ::std::strtol;
S      using ::std::strtoul;
S      using ::std::strtoll;
S      using ::std::strtoull;
S      using ::std::rand;
S      using ::std::srand;
S      using ::std::_rand_state;
S      using ::std::_rand_r;
S      using ::std::_srand_r;
S      using ::std::_ANSI_rand_state;
S      using ::std::_ANSI_rand_r;
S      using ::std::_ANSI_srand_r;
S      using ::std::calloc;
S      using ::std::free;
S      using ::std::malloc;
S      using ::std::realloc;
S#if !defined(__STRICT_ANSI__)
S      using ::std::posix_memalign;
S#endif
S      using ::std::__heapprt;
S      using ::std::__heapstats;
S      using ::std::__heapvalid;
S      using ::std::abort;
S      using ::std::atexit;
S      using ::std::exit;
S      using ::std::_Exit;
S      using ::std::getenv;
S      using ::std::system;
S      using ::std::bsearch;
S      using ::std::qsort;
S      using ::std::abs;
S      using ::std::div;
S      using ::std::labs;
S      using ::std::ldiv;
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::llabs;
S        using ::std::lldiv;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::__sdiv32by16;
S      using ::std::__udiv32by16;
S      using ::std::__sdiv64by32;
S      using ::std::__rt_sdiv32by16;
S      using ::std::__rt_udiv32by16;
S      using ::std::__rt_sdiv64by32;
S      using ::std::__fp_status;
S      using ::std::mblen;
S      using ::std::mbtowc;
S      using ::std::wctomb;
S      using ::std::mbstowcs;
S      using ::std::wcstombs;
S      using ::std::__use_realtime_heap;
S      using ::std::__use_realtime_division;
S      using ::std::__use_two_region_memory;
S      using ::std::__use_no_heap;
S      using ::std::__use_no_heap_region;
S      using ::std::__C_library_version_string;
S      using ::std::__C_library_version_number;
S      using ::std::size_t;
S      using ::std::__aeabi_MB_CUR_MAX;
S    #endif /* __STDLIB_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N/* end of stdlib.h */
N
L 14 "API\CIU98M25_API_Base_NoNVM.c" 2
N#include <string.h>
L 1 "C:\Keil_v4\ARM\ARMCC\bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5030076
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;
N#elif !defined(__size_t)
S  #define __size_t 1
S  typedef unsigned int size_t;   /* see <stddef.h> */
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 15 "API\CIU98M25_API_Base_NoNVM.c" 2
N
N#define FACTORY_CODE_SADDR 		0x1FFFFE00
N
N#define SCI_IS_IDLE                      (((SCISSR & 0x08) == 0) && ((SCIRXFCR & 0x02) != 0))
N/* MACRO DEFINE */
N/* 7816 Interface */
N#define SCI_START_SETU_COUNTER 				SET_REG_BIT(SCISSR,SCISSR_SETU)
N#define SCI_START_SETU_COUNTER_IS_RUNNING 	REG_BIT_IS_SET(SCISSR,SCISSR_SETU)
N#define SCI_IS_BUSY 					    (SCISSR & ((1 << SCISSR_RB)|(1 << SCISSR_TB)))
N#define CLEAR_SCI_AUTO_RETRY_LIMIT 		    (SCISCON &= ~(3 << SCISCON_RCNT_0))
N#define SET_SCI_AUTO_RETRY_LIMIT(num) 	    (SCISCON |= ((num - 2) & 0x3))
N#define ENABLE_SCI 						    SET_REG_BIT(SCISCON,SCISCON_SE)
N#define DISABLE_SCI 					    CLEAR_REG_BIT(SCISCON,SCISCON_SE) 
N/*7816 send data*/
N#define SCI_DATA_IS_SENDING 			    REG_BIT_IS_CLEAR(SCISSR,SCISSR_TI)
N#define CLEAR_SCI_TI 					    CLEAR_REG_BIT(SCISSR,SCISSR_TI)
N#define SCI_PARITY_IS_ERROR 			    REG_BIT_IS_SET(SCISSR,SCISSR_PE)
N#define CLEAR_SCI_PARITY_ERROR 			    CLEAR_REG_BIT(SCISSR,SCISSR_PE)
N#define FLUSH_SCI_TX_FIFO 				    SET_REG_BIT(SCITXFCR,SCITXFCR_FLUSH_TX_FIFO) 
N#define FLUSH_SCI_TX_FIFO_IS_RUNNING 	    REG_BIT_IS_SET(SCITXFCR, SCITXFCR_FLUSH_TX_FIFO)
N/*7816 receive data*/
N#define CLEAR_SCI_RI 					    CLEAR_REG_BIT(SCISSR,SCISSR_RI)
N#define SCIRXFCR_RX_IS_EMPTY  			    REG_BIT_IS_SET(SCIRXFCR,SCIRXFCR_RX_EMPTY)
N
N/* Random */
N#define ENABLE_RNG1_CLK 		            SET_REG_BIT(SYSCLKEN,SYSCLKEN_RNG1EN)
N#define DISABLE_RNG1_CLK 		            SET_REG_BIT(SYSCLKCLR,SYSCLKEN_RNG1EN)
N#define RANDOM_NUM_IS_OK 		            REG_BIT_IS_SET(RNG1STR,RNG1STR_RNGRDY)
N#define RANDOM_NUM_IS_NOT_OK 	            REG_BIT_IS_CLEAR(RNG1STR,RNG1STR_RNGRDY) 
N#define RANDOM_NUM_IS_TIMEOUT 	            REG_BIT_IS_SET(RNG1STR,RNG1STR_TIMEOUT)
N
N#define SET_REG_BIT(reg,bit) 			    (reg |= (1 << (bit)))
N#define CLEAR_REG_BIT(reg,bit) 			    (reg &= ~(1 << (bit)))
N#define REG_BIT_IS_SET(reg,bit) 		    (reg & (1 << (bit)))
N#define REG_BIT_IS_CLEAR(reg,bit) 		    ((reg & (1 << (bit))) == 0)
N#define SET_BIT(bit) 					    (0x1 << (bit))
N#define CLEAR_BIT(bit) 					    (~(0x1 << (bit)))
N
N//system register bits
Ntypedef  enum 
N{
N	SEC_SYSCLKEN_CRCEN = 0,
N	SEC_SYSCLKEN_DESEN = 1,
N	SEC_SYSCLKEN_SM1EN = 2,
N	SEC_SYSCLKEN_PKEEN = 4,
N	SEC_SYSCLKEN_AESEN = 5,    
N	SEC_SYSCLKEN_RNG1EN  = 8,
N	SEC_SYSCLKEN_TIMEREN = 9,
N	SEC_SYSCLKEN_WDTEN = 10,
N	SEC_SYSCLKEN_SM4EN = 11,
N	SEC_SYSCLKEN_SM3EN = 12,    
N	SEC_SYSCLKEN_SCIEN = 17,
N	SEC_SYSCLKEN_SPIEN = 18,    
N	SEC_SYSCLKEN_GPIOEN = 19,
N	SEC_SYSCLKEN_SWPEN = 20,    
N} SEC_SYSCLKEN_BITS;
N
Ntypedef enum 
N{
N	SYSRSTCFG_7816RSTEN = 2,
N	SYSRSTCFG_FDRSTEN = 3,
N	SYSRSTCFG_TDRSTEN = 4,
N    SYSRSTCFG_GDRSTEN = 5,
N	SYSRSTCFG_VDRSTEN = 6,
N    SYSRSTCFG_LDRSTEN = 7,
N	SYSRSTCFG_SECRSTEN = 8,
N} SYSRSTCFG_BITS;
N
N//SCI SFR
N//SCISCON bits
Ntypedef enum 
N{
N	SCISCON_RCNT_0 = 0,
N	SCISCON_RCNT_1 = 1,
N	SCISCON_PARITY = 2 ,
N	SCISCON_IVC = 3,
N	SCISCON_EGB = 4,
N	SCISCON_PS = 5,
N	SCISCON_SE = 6,
N    SCISCON_WTC = 7,
N    SCISCON_AWTS = 8,
N    SCISCON_SAFB = 10,
N    SCISCON_RTS = 11,
N} SCISCON_BITS;
N
N//SCISSR bits
Ntypedef enum 
N{
N	SCISSR_OE = 0,
N	SCISSR_PE = 1,
N	SCISSR_RI = 2 ,
N	SCISSR_RB = 3,
N	SCISSR_TI = 4,
N	SCISSR_TB = 5,
N	SCISSR_SETU = 6,
N} SCISSR_BITS;
N
Ntypedef enum 
N{
N	SCIRXFCR_FLUSH_RX_FIFO = 0,
N	SCIRXFCR_RX_EMPTY = 1,
N	SCIRXFCR_WATER_LEVEL = 2 ,
N} SCIRXFCR_BITS;
N
Ntypedef enum 
N{
N	SCITXFCR_FLUSH_TX_FIFO = 0,
N	SCITXFCR_TX_FULL = 1,
N} SCITXFCR_BITS;
N
N
N//timer
Ntypedef enum
N{
N	TIMERXCONTROL_ONESHOTCOUNT = 0,
N	TIMERXCONTROL_TIMERSIZE = 1,
N	TIMERXCONTROL_TIMERPRE = 2,
N	TIMERXCONTROL_ETUCOUNT = 4,
N	TIMERXCONTROL_TIMERMODE = 6,
N	TIMERXCONTROL_TIMERENABLE = 7,
N} TIMERXCONTROL_BITS;
N
Ntypedef enum
N{
N	TIMERXIS_TIMERINERRUPT = 0,
N} TIMERXIS_BITS;
N
N//CRC
Ntypedef enum
N{
N	CRCCSR_CRC_ST = 0,
N	CRCCSR_INPUT_REV = 1,
N	CRCCSR_OUTPUT_REV = 2,
N	CRCCSR_OUTPUT_NOT = 3,
N	CRCCSR_WIDTH_0 = 4,
N	CRCCSR_WIDTH_1 = 5,
N} CRCCSR_BITS;	
N
Ntypedef enum 
N{
N	SYSCLKCFG_SYSDIV = 4,
N    SYSCLKCFG_APBDIV = 12,
N    SYSCLKCFG_PKEDIV = 20,
N} SYSCLKCFG_BITS;
N
N/* Change Frequency */
Ntypedef enum
N{
N    SYSCLK_AHB_36Mhz =  0x0, 
N    SYSCLK_AHB_18Mhz  =  0x1, 
N    SYSCLK_AHB_15Mhz  =  0x2, 
N    SYSCLK_AHB_6Mhz  =  0x6, 
N}SYS_FREQUENCY_DIVISOR;
N
Ntypedef enum
N{
N	APB_EQU_AHB = 0,
N	APB_HALF_AHB = 1,
N} APB_FREQUENCY_DIVISOR;
N
N/* 7816 Interface */
N/************************************************* 
N  Function:      HED_T0_SendNBytes (unsigned char * DataAddr , unsigned int DataLen)
N  Description:    
N		send N bytes by 7816 interface(T = 0 protocol)			
N  Calls: none    
N  Input: 
N		DataAddr:address of the data to be sent
N		DataLen:lengtn of the data to be sent
N  Output:
N  Return:
N		0x00:data sent successfully
N		0x01:data sent fail
N		0x02:API's para illegal  
N  Others:none
N*************************************************/ 
Nunsigned int HED_T0_SendNBytes (unsigned char * DataAddr , unsigned int DataLen)
N{
N	if(DataLen == 0) 
N	{
N		return (2);
N	}
N
N	//wait for idle time
N	while(SCI_IS_BUSY); 
X	while(((*((volatile unsigned long *)(0x40001000 + 0x08 ))) & ((1 << SCISSR_RB)|(1 << SCISSR_TB)))); 
N
N	//set auto retry time = 3
N	CLEAR_SCI_AUTO_RETRY_LIMIT; 
X	((*((volatile unsigned long *)(0x40001000 + 0x04 ))) &= ~(3 << SCISCON_RCNT_0)); 
N	SET_SCI_AUTO_RETRY_LIMIT(3);
X	((*((volatile unsigned long *)(0x40001000 + 0x04 ))) |= ((3 - 2) & 0x3));
N
N	while(DataLen--)
N	{
N		//write one byte to buffer a time
N		SCISBUF = (*DataAddr++);
X		(*((volatile unsigned long *)(0x40001000 + 0x00 ))) = (*DataAddr++);
N		while(SCI_DATA_IS_SENDING);
X		while((((*((volatile unsigned long *)(0x40001000 + 0x08 ))) & (1 << (SCISSR_TI))) == 0));
N
N		if(SCI_PARITY_IS_ERROR == 0 )
X		if(((*((volatile unsigned long *)(0x40001000 + 0x08 ))) & (1 << (SCISSR_PE))) == 0 )
N		{
N			SCISSR = 0;							//clr SCI status
X			(*((volatile unsigned long *)(0x40001000 + 0x08 ))) = 0;							
N		}
N		else
N		{
N			SCITXFCR = 0x01;					//clr trans FIFO control
X			(*((volatile unsigned long *)(0x40001000 + 0x10 ))) = 0x01;					
N			while ((SCITXFCR & 0x01) == 0x01);
X			while (((*((volatile unsigned long *)(0x40001000 + 0x10 ))) & 0x01) == 0x01);
N			SCISSR = 0;							//clr SCI status
X			(*((volatile unsigned long *)(0x40001000 + 0x08 ))) = 0;							
N			return (1);    	
N		}
N	}
N	return (0);
N}
N/************************************************* 
N  Function:     HED_T0_ReceiveNBytesRam(unsigned char *DataAddr, unsigned int DataLen)
N  Description:    
N		receive N bytes to RAM by 7816 interface(T = 0 protocol)			
N  Calls: none              
N  Input: 
N		DataAddr:address to store the data received
N		DataLen:bytes number of the data received
N  Output:data received
N  Return:none
N  Others:none
N*************************************************/ 
Nvoid HED_T0_ReceiveNBytesRam(unsigned char *DataAddr, unsigned int DataLen)
N{
N	while(SCI_IS_BUSY);
X	while(((*((volatile unsigned long *)(0x40001000 + 0x08 ))) & ((1 << SCISSR_RB)|(1 << SCISSR_TB))));
N
N	while(DataLen--)
N	{	 	      
N		//wait for data
N		while(SCIRXFCR_RX_IS_EMPTY);
X		while(((*((volatile unsigned long *)(0x40001000 + 0x14 ))) & (1 << (SCIRXFCR_RX_EMPTY))));
N		(*DataAddr++) = (unsigned char)SCISBUF; 
X		(*DataAddr++) = (unsigned char)(*((volatile unsigned long *)(0x40001000 + 0x00 ))); 
N	}
N}
N
N/* CRC */
N#define CHANGE_CRC_WIDTH_FROM_32_TO_8  (CRCCSR |= (1<<5))
N/************************************************* 
N  Function:     unsigned short HED_CRC16(unsigned short IV, unsigned int DataLen, unsigned char *DataBuf, unsigned char type)
N  Description:    
N		Calculate the CRC-16 of a block of bytes in RAM/EE			
N  Calls:              
N  Input: 
N		DataLen:bytes number of the block of
N		IV: initial value
N		DataBuf: the address of the block of data to be calculate 
N		type: input and output data order type
N  Output:none
N  Return:2 bytes CRC result (big endian)
N  Others:none 
N*************************************************/ 
Nunsigned short HED_CRC16(unsigned short IV, unsigned int DataLen, unsigned char *DataBuf, unsigned char type)
N{
N	unsigned int tmp_cnt = (unsigned int)DataBuf & 0x3; //distance to previous word border
N	unsigned int div4_quotient, div4_mod;   //
N
N	if(DataLen == 0)
N	{
N		return IV;
N	}
N	
N	CRCIV = IV;
X	(*((volatile unsigned long *)(0x50005000 + 0x08 ))) = IV;
N	CRCCSR = ((type&0x3)<<1) | SET_BIT(CRCCSR_CRC_ST);
X	(*((volatile unsigned long *)(0x50005000 + 0x00 ))) = ((type&0x3)<<1) | (0x1 << (CRCCSR_CRC_ST));
N
N	if (DataLen <= 0x07)
N	{
N		div4_quotient = 0;
N		div4_mod = DataLen;   
N	}
N	else
N	{
N		unsigned int curr_crccsr = CRCCSR;
X		unsigned int curr_crccsr = (*((volatile unsigned long *)(0x50005000 + 0x00 )));
N		if (tmp_cnt)
N		{
N			tmp_cnt = 0x4 - tmp_cnt;
N			DataLen -= tmp_cnt;
N			CHANGE_CRC_WIDTH_FROM_32_TO_8;   //CRCCSR[5:4] = 10 ->8
X			((*((volatile unsigned long *)(0x50005000 + 0x00 ))) |= (1<<5));   
N			while (tmp_cnt--)
N			{
N				CRCDATA = *DataBuf++;
X				(*((volatile unsigned long *)(0x50005000 + 0x04 ))) = *DataBuf++;
N			}
N		}
N		div4_quotient = DataLen >> 0x02; 
N		div4_mod = DataLen & 0x3;   //word numbers
N		CRCCSR = curr_crccsr;
X		(*((volatile unsigned long *)(0x50005000 + 0x00 ))) = curr_crccsr;
N
N		if (div4_quotient)
N		{
N			unsigned int * tmp_databuf = (unsigned int *)DataBuf;
N			while (div4_quotient--)
N			{
N				CRCDATA = *(unsigned int *)tmp_databuf++;//4 bytes one time
X				(*((volatile unsigned long *)(0x50005000 + 0x04 ))) = *(unsigned int *)tmp_databuf++;
N			}
N			DataBuf = (unsigned char *)tmp_databuf;
N		}
N	}
N
N	if (div4_mod)	
N	{
N		CHANGE_CRC_WIDTH_FROM_32_TO_8;   //CRCCSR[5:4] = 10 ->8
X		((*((volatile unsigned long *)(0x50005000 + 0x00 ))) |= (1<<5));   
N		while (div4_mod--)
N		{
N			CRCDATA = *DataBuf++;
X			(*((volatile unsigned long *)(0x50005000 + 0x04 ))) = *DataBuf++;
N		}
N
N	}
N
N	return (unsigned short)CRCDATA;
X	return (unsigned short)(*((volatile unsigned long *)(0x50005000 + 0x04 )));
N}
N
N
N/* Serial Num */
Nvoid HED_GetChipInfo(unsigned char *DataBuf, unsigned int FlashAddr, unsigned int DataLen)
N{
N	while(DataLen--)
N	{
N		*DataBuf++ = *(unsigned char *)FlashAddr;
N		FlashAddr += 0x00000001;
N	}
N} 
N/* Chip ID */
N/************************************************* 
N  Function:     void HED_GetChipId(unsigned char *ChipId)
N  Description:  to get chip ID		
N  Calls:              
N  Input: ChipId:address to store the chip ID
N  Output:none
N  Return:
N  Others:none
N*************************************************/ 
Nvoid HED_GetChipId(unsigned char *ChipId)
N{
N    unsigned char die_YX_position;
N    unsigned char test_month;
N    
N    HED_GetChipInfo(ChipId,  FACTORY_CODE_SADDR+0x09, 1);	//Test year
X    HED_GetChipInfo(ChipId,  0x1FFFFE00+0x09, 1);	
N    
N    /*get 2nd sequence number*/
N    HED_GetChipInfo(&die_YX_position,  FACTORY_CODE_SADDR+0x17, 1);	//get die X/Y position on wafer
X    HED_GetChipInfo(&die_YX_position,  0x1FFFFE00+0x17, 1);	
N    HED_GetChipInfo(&test_month,  FACTORY_CODE_SADDR+0x0A, 1);	//get test_month
X    HED_GetChipInfo(&test_month,  0x1FFFFE00+0x0A, 1);	
N    die_YX_position = ((die_YX_position & 0x10) << 3) | ((die_YX_position & 0x01) << 6);    
N    test_month = (test_month >> 4)*10 + (test_month & 0x0F);
N    test_month &= 0x3F;
N    ChipId[1] = die_YX_position | test_month;
N    /*get 2nd sequence number*/
N    
N    HED_GetChipInfo(ChipId+2,  FACTORY_CODE_SADDR+0x1C, 1);	//lot number (highest byte)
X    HED_GetChipInfo(ChipId+2,  0x1FFFFE00+0x1C, 1);	
N    HED_GetChipInfo(ChipId+3,  FACTORY_CODE_SADDR+0x1D, 1);	//lot number (second byte)
X    HED_GetChipInfo(ChipId+3,  0x1FFFFE00+0x1D, 1);	
N    HED_GetChipInfo(ChipId+4,  FACTORY_CODE_SADDR+0x1E, 1);	//lot number (third byte)
X    HED_GetChipInfo(ChipId+4,  0x1FFFFE00+0x1E, 1);	
N    HED_GetChipInfo(ChipId+5,  FACTORY_CODE_SADDR+0x1F, 1);	//lot number (fourth byte)
X    HED_GetChipInfo(ChipId+5,  0x1FFFFE00+0x1F, 1);	
N    HED_GetChipInfo(ChipId+6,  FACTORY_CODE_SADDR+0x0B, 1);	//lot number (fifth byte)
X    HED_GetChipInfo(ChipId+6,  0x1FFFFE00+0x0B, 1);	
N    HED_GetChipInfo(ChipId+7,  FACTORY_CODE_SADDR+0x0C, 1);	//lot number (lowest byte)
X    HED_GetChipInfo(ChipId+7,  0x1FFFFE00+0x0C, 1);	
N    HED_GetChipInfo(ChipId+8,  FACTORY_CODE_SADDR+0x1A, 1);	//lot subsidiary number (high byte)
X    HED_GetChipInfo(ChipId+8,  0x1FFFFE00+0x1A, 1);	
N    HED_GetChipInfo(ChipId+9,  FACTORY_CODE_SADDR+0x1B, 1);	//lot subsidiary number (low byte)
X    HED_GetChipInfo(ChipId+9,  0x1FFFFE00+0x1B, 1);	
N    HED_GetChipInfo(ChipId+10,  FACTORY_CODE_SADDR+0x0D, 1); //wafer number
X    HED_GetChipInfo(ChipId+10,  0x1FFFFE00+0x0D, 1); 
N    HED_GetChipInfo(ChipId+11,  FACTORY_CODE_SADDR+0x0E, 1); //die X position on wafer
X    HED_GetChipInfo(ChipId+11,  0x1FFFFE00+0x0E, 1); 
N    HED_GetChipInfo(ChipId+12,  FACTORY_CODE_SADDR+0x0F, 1); //die Y position on wafer
X    HED_GetChipInfo(ChipId+12,  0x1FFFFE00+0x0F, 1); 
N}
N
N/* Factory Code */
N/************************************************* 
N  Function:     HED_GetFactoryCode(unsigned char *FactoryCode)
N  Description: to get 32 bytes long FactoryCode	
N  Calls:               
N  Input: address to store the FactoryCode
N  Output:none
N  Return:
N  Others: 
N*************************************************/ 
Nvoid HED_GetFactoryCode(unsigned char *FactoryCode)
N{
N	HED_GetChipInfo(FactoryCode, FACTORY_CODE_SADDR, 32);
X	HED_GetChipInfo(FactoryCode, 0x1FFFFE00, 32);
N}
N
N/*delay function
NPreFunction Instruction:
N
NMOVS    r0,0xxx;    //1 cycle
NBL      delay;      //4 cycle
N
NInFunction Instruction:
NloopStart
NSUBS     r0,r0,#1;  //1 cycle
NBCS      loopStart; //1 or 3 cycle
NBX		    lr;     //3 cycle
N
NLoopNum == 0:   delay == 10 cycle
NLoopNum == 1:   delay == 14 cycle
NLoopNum == 2:   delay == 18 cycle
N.........
NLoopNum == n:   delay == (10 + 4*n) cycle
N*/
N__asm void delay(unsigned int LoopNum)
N{
NloopStart
N    SUBS     r0,r0,#1
N    BCS      loopStart
N	BX		    lr
N}
N
N/************************************************* 
N  Function:     void HED_ChangeSYSFreq(SYS_FREQUENCY_DIVISOR SysDiv, APB_FREQUENCY_DIVISOR APBDiv) 
N  Description:  config the system clock	and APB div	
N  Calls:               
N  Input: 
N        typedef enum
N        {
N            SYSCLK_AHB_36Mhz =  0x0, 
N            SYSCLK_AHB_18Mhz  =  0x1, 
N            SYSCLK_AHB_15Mhz  =  0x2, 
N            SYSCLK_AHB_6Mhz  =  0x6, 
N        }SYS_FREQUENCY_DIVISOR;
N
N        typedef enum
N        {
N            APB_EQU_AHB = 0,
N            APB_HALF_AHB = 1,
N        } APB_FREQUENCY_DIVISOR;
N  Output:none
N  Return:none
N  Others:none
N*************************************************/ 
Nconst unsigned char SYS_PKE_ClkTable[7] = {0,1,1,7,7,7,7};
N
Nvoid HED_ChangeSYSFreq(SYS_FREQUENCY_DIVISOR SysDiv, APB_FREQUENCY_DIVISOR APBDiv) 
N{	
N	unsigned int currDiv,SysDivGap;
N	unsigned int tmpSysClk;    
N    
N	if (APBDiv == APB_HALF_AHB)
N	{
N		SET_REG_BIT(SYSCLKCFG,SYSCLKCFG_APBDIV);
X		((*((volatile unsigned long *)(0x50007000 + 0x208))) |= (1 << (SYSCLKCFG_APBDIV)));
N	}
N	else
N	{
N		CLEAR_REG_BIT(SYSCLKCFG, SYSCLKCFG_APBDIV);
X		((*((volatile unsigned long *)(0x50007000 + 0x208))) &= ~(1 << (SYSCLKCFG_APBDIV)));
N	}
N    
N	tmpSysClk = SYSCLKCFG;
X	tmpSysClk = (*((volatile unsigned long *)(0x50007000 + 0x208)));
N    currDiv = (SYSCLKCFG & (0x07 << SYSCLKCFG_SYSDIV)) >> SYSCLKCFG_SYSDIV;//sysclk is SYSCLKCFG[6:4]
X    currDiv = ((*((volatile unsigned long *)(0x50007000 + 0x208))) & (0x07 << SYSCLKCFG_SYSDIV)) >> SYSCLKCFG_SYSDIV;
N
N	if (currDiv == SysDiv)//no switch
N	{
N        tmpSysClk &= ~(0x07 << SYSCLKCFG_PKEDIV);
N        tmpSysClk |= (SYS_PKE_ClkTable[SysDiv] << SYSCLKCFG_PKEDIV);
N        SYSCLKCFG = tmpSysClk;//renew PKE Div        
X        (*((volatile unsigned long *)(0x50007000 + 0x208))) = tmpSysClk;
N        return;
N	}
N	else if(currDiv > SysDiv)//up switch
N	{
N        SysDivGap = currDiv - SysDiv;
N	}	
N    else//down switch
N    {
N        SysDivGap = SysDiv - currDiv;
N    }
N    
N    if((SysDivGap == 2) || (SysDivGap == 6))//SysDIV switch to 18M first,then target Div
N    {
N        tmpSysClk &= ~(0x07 << SYSCLKCFG_SYSDIV);
N        tmpSysClk |= (1 << SYSCLKCFG_SYSDIV); //prepare switch to 18Mhz 
N        SYSCLKCFG = tmpSysClk; 
X        (*((volatile unsigned long *)(0x50007000 + 0x208))) = tmpSysClk; 
N        delay(43);//delay 10us when 18Mhz
N        tmpSysClk &= ~(0x07 << SYSCLKCFG_SYSDIV);
N        tmpSysClk |= (SysDiv <<SYSCLKCFG_SYSDIV);//prepare switch to target Div
N        SYSCLKCFG = tmpSysClk;
X        (*((volatile unsigned long *)(0x50007000 + 0x208))) = tmpSysClk;
N    }
N    else//SysDIV switch to target Div directly
N    {
N        tmpSysClk &= ~(0x07 << SYSCLKCFG_SYSDIV);
N        tmpSysClk |= (SysDiv <<SYSCLKCFG_SYSDIV);//prepare switch to target SYSDIV  
N        SYSCLKCFG = tmpSysClk;            
X        (*((volatile unsigned long *)(0x50007000 + 0x208))) = tmpSysClk;            
N    }    
N    
N    tmpSysClk &= ~(0x07 << SYSCLKCFG_PKEDIV);
N    tmpSysClk |= (SYS_PKE_ClkTable[SysDiv] << SYSCLKCFG_PKEDIV);
N    SYSCLKCFG = tmpSysClk;//set PKE Div
X    (*((volatile unsigned long *)(0x50007000 + 0x208))) = tmpSysClk;
N}
N
N/* Set standby Mode */
Nextern unsigned char G_bSWP_busy;
N/************************************************* 
N  Function:     HED_SetToStandby(void)
N  Description:  set chip to standby mode		
N  Calls:              
N  Input: none
N  Output:none
N  Return:
N  Others: both SYSCLKCFG and SYSCLKEN remain the same before and after the execution of this API
N*************************************************/ 
Nvoid HED_SetToStandby(void)
N{
N	unsigned int bak_SYSCLKEN,bak_SYSCLKCFG;
N    unsigned int bak_SYSDiv,bak_APBDiv;
N    
N    bak_SYSCLKEN = SYSCLKEN;
X    bak_SYSCLKEN = (*((volatile unsigned long *)(0x50007000 + 0x200)));
N    bak_SYSCLKCFG = SYSCLKCFG;
X    bak_SYSCLKCFG = (*((volatile unsigned long *)(0x50007000 + 0x208)));
N    bak_SYSDiv = (bak_SYSCLKCFG & (0x07 << SYSCLKCFG_SYSDIV)) >> SYSCLKCFG_SYSDIV;//sysclk is SYSCLKCFG[6:4]
N    bak_APBDiv = (bak_SYSCLKCFG & (0x01 << SYSCLKCFG_APBDIV)) >> SYSCLKCFG_APBDIV;//sysclk is SYSCLKCFG[bit12]
N
N	SYSCLKCLR = (1<<4) | (1<<11); //disable PKE/SM4 IP's clock
X	(*((volatile unsigned long *)(0x50007000 + 0x204))) = (1<<4) | (1<<11); 
N    
N    HED_ChangeSYSFreq(SYSCLK_AHB_6Mhz,APB_HALF_AHB);
N    
N	if((SCI_IS_IDLE) && (G_bSWP_busy == 0x00))
X	if((((((*((volatile unsigned long *)(0x40001000 + 0x08 ))) & 0x08) == 0) && (((*((volatile unsigned long *)(0x40001000 + 0x14 ))) & 0x02) != 0))) && (G_bSWP_busy == 0x00))
N    {
N         __wfe(); //set standby
N    }
N    
N    if((bak_SYSDiv == 0) || (bak_SYSDiv == 1) || (bak_SYSDiv == 2) || (bak_SYSDiv == 6))
N    {
N        HED_ChangeSYSFreq((SYS_FREQUENCY_DIVISOR)bak_SYSDiv,(APB_FREQUENCY_DIVISOR)bak_APBDiv);//restore SYSCLKCFG
N    }
N    
N	SYSCLKEN = bak_SYSCLKEN;//enable IP's CLK							
X	(*((volatile unsigned long *)(0x50007000 + 0x200))) = bak_SYSCLKEN;
N}
N
N/*SPI*/
Ntypedef enum 
N{
N	SPICON_MSTR = 0,
N	SPICON_CPHA = 1,
N	SPICON_CPOL = 2,
N	SPICON_LSBFE = 3,
N	SPICON_MODSEL = 4,
N} SPICON_BITS;
N
Ntypedef enum 
N{
N	SPIST_DONE = 0,
N	SPIST_OVRF = 1,
N} SPIST_BITS;
N
Ntypedef enum 
N{
N	SPIDIV_DIV = 0,
N	SPIDIV_MDIV_EN = 8,
N} SPIDIV_BITS;
N
Ntypedef enum 
N{
N	SPIIE_DONEI_EN = 0,
N	SPIIE_OVRFI_EN = 1,
N} SPIIE_BITS;
N
Ntypedef enum 
N{
N	SPIIS_DONE_INT = 0,
N	SPIIS_OVRF_INT = 1,
N} SPIIS_BITS;
N
Ntypedef enum 
N{
N	SPISTR_TRE = 0,
N} SPISTR_BITS;
N
N/* SPI-Master */
N#define SET_SPI_MSTR 				SET_REG_BIT(SPICON,SPICON_MSTR)
N#define DISABLE_SPI_MSTR_DONE_INT 	CLEAR_REG_BIT(SPIIE,SPIIE_DONEI_EN)
N#define START_SPI_MSTR_TRANS 		SET_REG_BIT(SPISTR,SPISTR_TRE)
N#define SPI_IS_BUSY 				REG_BIT_IS_CLEAR(SPIST,SPIST_DONE)
N#define CLEAR_SPI_DONE CLEAR_REG_BIT(SPIST,SPIST_DONE) ;\
N	CLEAR_REG_BIT(SPIIS,SPIIS_DONE_INT)
X#define CLEAR_SPI_DONE CLEAR_REG_BIT(SPIST,SPIST_DONE) ;	CLEAR_REG_BIT(SPIIS,SPIIS_DONE_INT)
N/* SPI-Slave */
N#define SET_SPI_SLAVE 					CLEAR_REG_BIT(SPICON,SPICON_MSTR)
N#define SPI_SLAVE_RECEIVER_IS_OVERFLOW 	REG_BIT_IS_SET(SPIST,SPIST_OVRF)
N#define CLEAR_SPI_RECEIVER_OVERFLOW 	CLEAR_REG_BIT(SPIST,SPIST_OVRF)
N
N/************************************************* 
N  Function:     HED_Memcpy
N  Description:  sub function		
N  Calls:              
N  Input: 
N  Output:
N  Return:
N  Others: 
N*************************************************/ 
Nvoid HED_Memcpy(unsigned char* to,unsigned char* from,unsigned int count)
N{
N	while(count-- != 0)
N	{
N		*to++ = *from++;
N	}
N}
N/************************************************* 
N  Function:     HED_WordEndianAlter
N  Description: 		
N  Calls:              
N  Input: 
N  Output:
N  Return:
N  Others: 
N*************************************************/ 
Nunsigned int HED_WordEndianAlter(unsigned int inWord)
N{
N	unsigned int outWord;
N    unsigned char* tmpBytePtr;
N    
N    tmpBytePtr = (unsigned char*)(&outWord);
N    tmpBytePtr[0] = inWord >> 0;
N    tmpBytePtr[1] = inWord >> 8;
N    tmpBytePtr[2] = inWord >> 16;
N    tmpBytePtr[3] = inWord >> 24;
N    
N    return outWord;
N}
N/* SPI-Master */
N/************************************************* 
N  Function:     HED_SPIM_SendNBytes(unsigned char *DataAddr, unsigned int DataLen)
N  Description:  		
N  Calls:              
N  Input: none
N  Output:none
N  Return:
N  Others: 
N*************************************************/ 
Nvoid HED_SPIM_SendNBytes(unsigned char *DataAddr, unsigned int DataLen)
N{
N	unsigned int div16Quotien, div16Mod;
N	unsigned int * tmpDataAddr,* tmpSpiData;
N	unsigned int disToPreviousWord,disToNextWord; //distance to previous/next word border
N	
N    disToPreviousWord = (unsigned int)DataAddr & 0x03;
N    disToNextWord = 0x04 - disToPreviousWord;
N	if (DataLen == 0x00)
N	{
N		return;
N	}
N
N	if (disToPreviousWord) 
N	{
N		if (DataLen <= 0x04)
N		{
N			SPIDLEN = DataLen - 1; 
X			(*((volatile unsigned long *)(0x40001800 + 0x04 ))) = DataLen - 1; 
N			SPIDATA = (unsigned int)((DataAddr[3] << 24) | (DataAddr[2] << 16) | (DataAddr[1] << 8) | DataAddr[0]);
X			(*((volatile unsigned long *)(0x40001800 + 0x40 ))) = (unsigned int)((DataAddr[3] << 24) | (DataAddr[2] << 16) | (DataAddr[1] << 8) | DataAddr[0]);
N			START_SPI_MSTR_TRANS; //transfer start
X			((*((volatile unsigned long *)(0x40001800 + 0x18 ))) |= (1 << (SPISTR_TRE))); 
N			while (SPI_IS_BUSY);
X			while ((((*((volatile unsigned long *)(0x40001800 + 0x08 ))) & (1 << (SPIST_DONE))) == 0));
N			CLEAR_SPI_DONE; 
X			((*((volatile unsigned long *)(0x40001800 + 0x08 ))) &= ~(1 << (SPIST_DONE))) ; ((*((volatile unsigned long *)(0x40001800 + 0x14 ))) &= ~(1 << (SPIIS_DONE_INT))); 
N			return;
N		}
N		else //front n bytes
N		{
N			SPIDLEN = disToNextWord - 0x01;
X			(*((volatile unsigned long *)(0x40001800 + 0x04 ))) = disToNextWord - 0x01;
N            SPIDATA = (unsigned int)((DataAddr[3] << 24) | (DataAddr[2] << 16) | (DataAddr[1] << 8) | DataAddr[0]);
X            (*((volatile unsigned long *)(0x40001800 + 0x40 ))) = (unsigned int)((DataAddr[3] << 24) | (DataAddr[2] << 16) | (DataAddr[1] << 8) | DataAddr[0]);
N			START_SPI_MSTR_TRANS; //transfer start
X			((*((volatile unsigned long *)(0x40001800 + 0x18 ))) |= (1 << (SPISTR_TRE))); 
N			while (SPI_IS_BUSY);
X			while ((((*((volatile unsigned long *)(0x40001800 + 0x08 ))) & (1 << (SPIST_DONE))) == 0));
N			CLEAR_SPI_DONE;
X			((*((volatile unsigned long *)(0x40001800 + 0x08 ))) &= ~(1 << (SPIST_DONE))) ; ((*((volatile unsigned long *)(0x40001800 + 0x14 ))) &= ~(1 << (SPIIS_DONE_INT)));
N			DataLen -= disToNextWord;
N			DataAddr += disToNextWord;
N		}
N	}
N	div16Quotien = DataLen >> 4; 
N	div16Mod = DataLen & 0xF;
N	tmpDataAddr = (unsigned int *)DataAddr;
N	if (div16Quotien)
N	{
N		//16 bytes a time
N		SPIDLEN = 0xF; 
X		(*((volatile unsigned long *)(0x40001800 + 0x04 ))) = 0xF; 
N		while (div16Quotien--)
N		{
N			tmpSpiData = (unsigned int *)&SPIDATA;
X			tmpSpiData = (unsigned int *)&(*((volatile unsigned long *)(0x40001800 + 0x40 )));
N            
N            *tmpSpiData++ = HED_WordEndianAlter(*tmpDataAddr++);
N            *tmpSpiData++ = HED_WordEndianAlter(*tmpDataAddr++);
N            *tmpSpiData++ = HED_WordEndianAlter(*tmpDataAddr++);
N            *tmpSpiData++ = HED_WordEndianAlter(*tmpDataAddr++);
N
N			START_SPI_MSTR_TRANS; //transfer start
X			((*((volatile unsigned long *)(0x40001800 + 0x18 ))) |= (1 << (SPISTR_TRE))); 
N			while (SPI_IS_BUSY);
X			while ((((*((volatile unsigned long *)(0x40001800 + 0x08 ))) & (1 << (SPIST_DONE))) == 0));
N			CLEAR_SPI_DONE; 
X			((*((volatile unsigned long *)(0x40001800 + 0x08 ))) &= ~(1 << (SPIST_DONE))) ; ((*((volatile unsigned long *)(0x40001800 + 0x14 ))) &= ~(1 << (SPIIS_DONE_INT))); 
N		}
N	}
N
N	if (div16Mod)
N	{
N		SPIDLEN = div16Mod - 1; //left bytes
X		(*((volatile unsigned long *)(0x40001800 + 0x04 ))) = div16Mod - 1; 
N		tmpSpiData = (unsigned int *)&SPIDATA;
X		tmpSpiData = (unsigned int *)&(*((volatile unsigned long *)(0x40001800 + 0x40 )));
N        *tmpSpiData++ = HED_WordEndianAlter(*tmpDataAddr++);
N        *tmpSpiData++ = HED_WordEndianAlter(*tmpDataAddr++);
N        *tmpSpiData++ = HED_WordEndianAlter(*tmpDataAddr++);
N        *tmpSpiData++ = HED_WordEndianAlter(*tmpDataAddr++);
N		START_SPI_MSTR_TRANS; //transfer start 
X		((*((volatile unsigned long *)(0x40001800 + 0x18 ))) |= (1 << (SPISTR_TRE))); 
N		while (SPI_IS_BUSY);
X		while ((((*((volatile unsigned long *)(0x40001800 + 0x08 ))) & (1 << (SPIST_DONE))) == 0));
N		CLEAR_SPI_DONE;
X		((*((volatile unsigned long *)(0x40001800 + 0x08 ))) &= ~(1 << (SPIST_DONE))) ; ((*((volatile unsigned long *)(0x40001800 + 0x14 ))) &= ~(1 << (SPIIS_DONE_INT)));
N	}
N}
N/************************************************* 
N  Function:     HED_SPIM_ReceiveNBytesRam(unsigned char *DataAddr, unsigned int DataLen)
N  Description:  		
N  Calls:              
N  Input: none
N  Output:none
N  Return:
N  Others: 
N*************************************************/ 
Nvoid HED_SPIM_ReceiveNBytesRam(unsigned char *DataAddr, unsigned int DataLen)
N{
N	unsigned int div16Quotien, div16Mod;
N	unsigned int* tmpDataAddr,*tmpSpiData;
N	unsigned int disToPreviousWord,disToNextWord; //distance to previous/next word border
N	unsigned int databuf[4];
N    
N    disToPreviousWord = (unsigned int)DataAddr & 0x03;
N	disToNextWord = 0x04 - disToPreviousWord;
N	if (DataLen == 0x00)
N	{
N		return;
N	}
N	if (disToPreviousWord)
N	{
N		tmpDataAddr = databuf;
N		tmpSpiData = (unsigned int *)&SPIDATA;
X		tmpSpiData = (unsigned int *)&(*((volatile unsigned long *)(0x40001800 + 0x40 )));
N		if (DataLen <= 0x10)
N		{
N			SPIDLEN = DataLen - 1;
X			(*((volatile unsigned long *)(0x40001800 + 0x04 ))) = DataLen - 1;
N			START_SPI_MSTR_TRANS; 
X			((*((volatile unsigned long *)(0x40001800 + 0x18 ))) |= (1 << (SPISTR_TRE))); 
N			while (SPI_IS_BUSY);
X			while ((((*((volatile unsigned long *)(0x40001800 + 0x08 ))) & (1 << (SPIST_DONE))) == 0));
N
N			//read 16 bytes
N			*tmpDataAddr++ = HED_WordEndianAlter(*tmpSpiData++);
N			*tmpDataAddr++ = HED_WordEndianAlter(*tmpSpiData++);
N			*tmpDataAddr++ = HED_WordEndianAlter(*tmpSpiData++);
N			*tmpDataAddr++ = HED_WordEndianAlter(*tmpSpiData++);
N
N			CLEAR_SPI_DONE; 
X			((*((volatile unsigned long *)(0x40001800 + 0x08 ))) &= ~(1 << (SPIST_DONE))) ; ((*((volatile unsigned long *)(0x40001800 + 0x14 ))) &= ~(1 << (SPIIS_DONE_INT))); 
N			HED_Memcpy(DataAddr,(unsigned char*)databuf,DataLen);
N			return;
N		}
N		else
N		{
N			SPIDLEN = disToNextWord - 0x01;
X			(*((volatile unsigned long *)(0x40001800 + 0x04 ))) = disToNextWord - 0x01;
N			START_SPI_MSTR_TRANS; 
X			((*((volatile unsigned long *)(0x40001800 + 0x18 ))) |= (1 << (SPISTR_TRE))); 
N			while (SPI_IS_BUSY);
X			while ((((*((volatile unsigned long *)(0x40001800 + 0x08 ))) & (1 << (SPIST_DONE))) == 0));
N			//read 
N            *tmpDataAddr++ = HED_WordEndianAlter(SPIDATA);
X            *tmpDataAddr++ = HED_WordEndianAlter((*((volatile unsigned long *)(0x40001800 + 0x40 ))));
N
N			CLEAR_SPI_DONE; 
X			((*((volatile unsigned long *)(0x40001800 + 0x08 ))) &= ~(1 << (SPIST_DONE))) ; ((*((volatile unsigned long *)(0x40001800 + 0x14 ))) &= ~(1 << (SPIIS_DONE_INT))); 
N			HED_Memcpy(DataAddr,(unsigned char*)databuf,disToNextWord);
N			DataAddr += disToNextWord;
N			DataLen -= disToNextWord;
N		}
N	}
N
N	div16Quotien = DataLen >> 4; 
N	div16Mod = DataLen & 0xF;
N	tmpDataAddr = (unsigned int *)DataAddr;
N	if (div16Quotien)
N	{
N		//SPIDLEN
N		SPIDLEN = 0xF; //16 bytes a time
X		(*((volatile unsigned long *)(0x40001800 + 0x04 ))) = 0xF; 
N		while (div16Quotien--)
N		{
N			tmpSpiData = (unsigned int *)&SPIDATA;
X			tmpSpiData = (unsigned int *)&(*((volatile unsigned long *)(0x40001800 + 0x40 )));
N			START_SPI_MSTR_TRANS; 
X			((*((volatile unsigned long *)(0x40001800 + 0x18 ))) |= (1 << (SPISTR_TRE))); 
N			while (SPI_IS_BUSY);
X			while ((((*((volatile unsigned long *)(0x40001800 + 0x08 ))) & (1 << (SPIST_DONE))) == 0));
N            
N            *tmpDataAddr++ = HED_WordEndianAlter(*tmpSpiData++);
N            *tmpDataAddr++ = HED_WordEndianAlter(*tmpSpiData++);
N            *tmpDataAddr++ = HED_WordEndianAlter(*tmpSpiData++);
N            *tmpDataAddr++ = HED_WordEndianAlter(*tmpSpiData++);
N			CLEAR_SPI_DONE; 
X			((*((volatile unsigned long *)(0x40001800 + 0x08 ))) &= ~(1 << (SPIST_DONE))) ; ((*((volatile unsigned long *)(0x40001800 + 0x14 ))) &= ~(1 << (SPIIS_DONE_INT))); 
N		}
N		DataAddr = (unsigned char *)tmpDataAddr;
N	}
N
N	if (div16Mod)
N	{
N		SPIDLEN = div16Mod - 1; //left bytes
X		(*((volatile unsigned long *)(0x40001800 + 0x04 ))) = div16Mod - 1; 
N		tmpDataAddr = databuf;
N		tmpSpiData = (unsigned int *)&SPIDATA;
X		tmpSpiData = (unsigned int *)&(*((volatile unsigned long *)(0x40001800 + 0x40 )));
N		START_SPI_MSTR_TRANS; 
X		((*((volatile unsigned long *)(0x40001800 + 0x18 ))) |= (1 << (SPISTR_TRE))); 
N		while (SPI_IS_BUSY);
X		while ((((*((volatile unsigned long *)(0x40001800 + 0x08 ))) & (1 << (SPIST_DONE))) == 0));
N
N		//read 16 bytes
N		*tmpDataAddr++ = HED_WordEndianAlter(*tmpSpiData++);
N		*tmpDataAddr++ = HED_WordEndianAlter(*tmpSpiData++);
N		*tmpDataAddr++ = HED_WordEndianAlter(*tmpSpiData++);
N		*tmpDataAddr++ = HED_WordEndianAlter(*tmpSpiData++);    
N		CLEAR_SPI_DONE; 
X		((*((volatile unsigned long *)(0x40001800 + 0x08 ))) &= ~(1 << (SPIST_DONE))) ; ((*((volatile unsigned long *)(0x40001800 + 0x14 ))) &= ~(1 << (SPIIS_DONE_INT))); 
N
N		HED_Memcpy(DataAddr,(unsigned char*)databuf,div16Mod);
N	}
N}
N/* SPI-Slave */
N/************************************************* 
N  Function:     HED_SPIS_SendNBytes(unsigned char *DataAddr, unsigned int DataLen)
N  Description:  		
N  Calls:              
N  Input: none
N  Output:none
N  Return:
N  Others: 
N*************************************************/ 
Nvoid HED_SPIS_SendNBytes(unsigned char *DataAddr, unsigned int DataLen)
N{
N	unsigned int tmpSpiden,tmpDataNum;
N
N	__packed unsigned int* tmpDataAddr;
N	unsigned int* tmpSpiData;
N
N    tmpSpiden = 0;
N    tmpDataNum = 0;
N	while (tmpDataNum < DataLen)
N	{
N		tmpDataAddr = (__packed unsigned int*)DataAddr;
N
N		//write 16 bytes to buffer every time
N		tmpSpiData = (unsigned int *)&SPIDATA;
X		tmpSpiData = (unsigned int *)&(*((volatile unsigned long *)(0x40001800 + 0x40 )));
N        *tmpSpiData++ = HED_WordEndianAlter(*tmpDataAddr++);
N        *tmpSpiData++ = HED_WordEndianAlter(*tmpDataAddr++);
N        *tmpSpiData++ = HED_WordEndianAlter(*tmpDataAddr++);
N        *tmpSpiData++ = HED_WordEndianAlter(*tmpDataAddr++);
N		
N		CLEAR_SPI_DONE;
X		((*((volatile unsigned long *)(0x40001800 + 0x08 ))) &= ~(1 << (SPIST_DONE))) ; ((*((volatile unsigned long *)(0x40001800 + 0x14 ))) &= ~(1 << (SPIIS_DONE_INT)));
N		while (SPI_IS_BUSY);//wait transfer over
X		while ((((*((volatile unsigned long *)(0x40001800 + 0x08 ))) & (1 << (SPIST_DONE))) == 0));
N
N		//read spidlen
N		tmpSpiden = SPIDLEN+1; //how many bytes transfer success
X		tmpSpiden = (*((volatile unsigned long *)(0x40001800 + 0x04 )))+1; 
N		tmpDataNum += tmpSpiden;
N		DataAddr += tmpSpiden;
N	}
N}
N/************************************************* 
N  Function:     HED_SPIS_ReceiveNBytesRam(unsigned char *DataAddr, unsigned int DataLen)
N  Description:  		
N  Calls:              
N  Input: none
N  Output:none
N  Return:
N  Others: 
N*************************************************/ 
Nunsigned char HED_SPIS_ReceiveNBytesRam(unsigned char *DataAddr, unsigned int DataLen)
N{
N
N	unsigned int tmpSpiden = 0,tmpDataNum = 0;
N	unsigned int databuf[4];
N	unsigned int* tmpDataAddr,*tmpSpiData;
N
N	while (tmpDataNum < DataLen)
N	{
N		tmpDataAddr = databuf;
N		tmpSpiData = (unsigned int *)&SPIDATA;
X		tmpSpiData = (unsigned int *)&(*((volatile unsigned long *)(0x40001800 + 0x40 )));
N		while (SPI_IS_BUSY);
X		while ((((*((volatile unsigned long *)(0x40001800 + 0x08 ))) & (1 << (SPIST_DONE))) == 0));
N		if (SPI_SLAVE_RECEIVER_IS_OVERFLOW)
X		if (((*((volatile unsigned long *)(0x40001800 + 0x08 ))) & (1 << (SPIST_OVRF))))
N		{
N			CLEAR_SPI_RECEIVER_OVERFLOW;
X			((*((volatile unsigned long *)(0x40001800 + 0x08 ))) &= ~(1 << (SPIST_OVRF)));
N			return (1);
N		}	
N		//read spidlen
N		tmpSpiden = SPIDLEN+1; //received bytes 
X		tmpSpiden = (*((volatile unsigned long *)(0x40001800 + 0x04 )))+1; 
N        *tmpDataAddr++ = HED_WordEndianAlter(*tmpSpiData++);
N        *tmpDataAddr++ = HED_WordEndianAlter(*tmpSpiData++);
N        *tmpDataAddr++ = HED_WordEndianAlter(*tmpSpiData++);
N        *tmpDataAddr++ = HED_WordEndianAlter(*tmpSpiData++);
N		HED_Memcpy(DataAddr,(unsigned char *)databuf,tmpSpiden);
N		DataAddr += tmpSpiden;
N		tmpDataNum += tmpSpiden;
N        if(tmpDataNum < DataLen)
N        {
N            CLEAR_SPI_DONE;
X            ((*((volatile unsigned long *)(0x40001800 + 0x08 ))) &= ~(1 << (SPIST_DONE))) ; ((*((volatile unsigned long *)(0x40001800 + 0x14 ))) &= ~(1 << (SPIIS_DONE_INT)));
N        }		          
N	}
N	return (0);
N}
