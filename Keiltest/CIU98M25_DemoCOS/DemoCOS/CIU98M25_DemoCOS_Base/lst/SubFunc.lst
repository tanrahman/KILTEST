L 1 "SRC\SubFunc.c"
N/*****************************************************
N Copyright(C),CEC Huada Electronic Design Co.,Ltd.
N 
N Project name: 	SubFunc.c
N Author:    	
N Version:		
N Date:  		
N Description: 
N History:	
N******************************************************/
N#include "../inc/Declare.h"
L 1 "SRC\../inc/Declare.h" 1
N/*****************************************************
N Copyright(C),CEC Huada Electronic Design Co.,Ltd.
N 
N Project name: 	Declare.h
N Author:    	
N Version:		
N Date:  		
N Description: 
N History:	
N******************************************************/
N#ifndef _DECLARE_H_
N#define _DECLARE_H_
N
N#include <string.h>
L 1 "C:\Keil_v4\ARM\ARMCC\bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5030076
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;
N#elif !defined(__size_t)
S  #define __size_t 1
S  typedef unsigned int size_t;   /* see <stddef.h> */
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 15 "SRC\../inc/Declare.h" 2
N#include <absacc.h>
L 1 "C:\Keil_v4\ARM\ARMCC\bin\..\include\absacc.h" 1
N/* absacc.h: header file that allows absolute variable location at C level */
N/* Copyright 2006-2007 ARM Limited. All rights reserved.                       */
N/* version 1.01 */
N
N
N#ifndef __at
N#define __at(_addr) __attribute__ ((at(_addr)))
N
N#endif
N
N#ifndef __section
N#define __section(_name) __attribute__ ((section(_name)))
N
N#endif
L 16 "SRC\../inc/Declare.h" 2
N#include "CIU98M25_SFR_C.h"
L 1 "SRC\../inc/CIU98M25_SFR_C.h" 1
N/******************** (C) COPYRIGHT 2014 HED *************************************
N* File Name          : CIU98M25_SFR_C.h
N* Author             : lursh
N* Date First Issued  : 2014-12-1
N* Description        : This file describes the register map of CIU98M25
N// ------------------------------------------------------------
N// Modification History:
N// Version    Date       Author    Modification Description
N// V0.0      2014-12-1   lursh     initial version
N*********************************************************************************/
N
N#ifndef __IO_CIU98M25_H
N#define __IO_CIU98M25_H
N
N/********************************************************************************
N                      AMBA IP AHB Peripherals Addresse
N********************************************************************************/
N/********************************************************************************
N                             CRC Regsiter
N********************************************************************************/
N#define CRCCSR               (*((volatile unsigned long *)(0x50005000 + 0x00 )))
N#define CRCDATA              (*((volatile unsigned long *)(0x50005000 + 0x04 )))
N#define CRCIV                (*((volatile unsigned long *)(0x50005000 + 0x08 )))
N
N/********************************************************************************
N                             SystemController Regsiter
N********************************************************************************/
N// EMMU
N#define SYSEMMUCON           (*((volatile unsigned long *)(0x50007000 + 0x1C )))
N#define SYSCMSBCS            (*((volatile unsigned long *)(0x50007000 + 0x20 )))
N#define SYSNVMDEADDR         (*((volatile unsigned long *)(0x50007000 + 0x28 )))
N#define SYSSWITCHTAG1        (*((volatile unsigned long *)(0x50007000 + 0x30 )))
N#define SYSSWITCHTAG2        (*((volatile unsigned long *)(0x50007000 + 0x34 )))
N#define SYSSWITCHTAG3        (*((volatile unsigned long *)(0x50007000 + 0x38 )))
N
N// NVM
N#define SYSNVMSTATUS         (*((volatile unsigned long *)(0x50007000 + 0x80 )))
N#define SYSNVMMODE           (*((volatile unsigned long *)(0x50007000 + 0x84 )))
N#define SYSNVMCON            (*((volatile unsigned long *)(0x50007000 + 0x88 )))
N#define SYSVERIERRADDR       (*((volatile unsigned long *)(0x50007000 + 0x8C )))
N#define SYSNVMABTADDR        (*((volatile unsigned long *)(0x50007000 + 0x90 )))
N#define SYSNVMSDPK1          (*((volatile unsigned long *)(0x50007000 + 0xA0 )))
N#define SYSNVMSDPK2          (*((volatile unsigned long *)(0x50007000 + 0xA4 )))
N#define SYSNVMSDPK3          (*((volatile unsigned long *)(0x50007000 + 0xA8 )))
N#define SYSECCSTADDR         (*((volatile unsigned long *)(0x50007000 + 0xEC )))
N
N// RSTMU
N#define SYSINFST             (*((volatile unsigned long *)(0x50007000 + 0x180)))
N#define SYSRSTFLAG           (*((volatile unsigned long *)(0x50007000 + 0x184)))
N#define SYSRSTCFG            (*((volatile unsigned long *)(0x50007000 + 0x188)))
N#define SYSINTCLR            (*((volatile unsigned long *)(0x50007000 + 0x190)))
N#define SYSPUDCON            (*((volatile unsigned long *)(0x50007000 + 0x194)))
N#define SYSVDFLAG            (*((volatile unsigned long *)(0x50007000 + 0x198)))
N#define SYSINFCON            (*((volatile unsigned long *)(0x50007000 + 0x19C)))
N
N// CKMU
N#define SYSCLKEN             (*((volatile unsigned long *)(0x50007000 + 0x200)))
N#define SYSCLKCLR            (*((volatile unsigned long *)(0x50007000 + 0x204)))
N#define SYSCLKCFG            (*((volatile unsigned long *)(0x50007000 + 0x208)))
N
N// POWMU
N#define SYSPCON1             (*((volatile unsigned long *)(0x50007000 + 0x280)))
N#define SYSPCON3             (*((volatile unsigned long *)(0x50007000 + 0x288)))
N#define SYSWKPCALIB          (*((volatile unsigned long *)(0x50007000 + 0x28C)))
N#define SYSWKPCON            (*((volatile unsigned long *)(0x50007000 + 0x290)))
N#define SYSVR12PB            (*((volatile unsigned long *)(0x50007000 + 0x294)))
N#define SYSNVMVR12PB         (*((volatile unsigned long *)(0x50007000 + 0x298)))
N#define SYSVR18PB            (*((volatile unsigned long *)(0x50007000 + 0x29C)))
N
N// INTC
N#define SYSIRQLR             (*((volatile unsigned long *)(0x50007000 + 0x380)))
N#define SYSNMICON            (*((volatile unsigned long *)(0x50007000 + 0x384)))
N
N// SEC
N#define SECCTR               (*((volatile unsigned long *)(0x50007000 + 0x400)))
N#define SECMEINIH            (*((volatile unsigned long *)(0x50007000 + 0x404)))
N#define SECMEINIL            (*((volatile unsigned long *)(0x50007000 + 0x408)))
N#define SECPKEMEINI          (*((volatile unsigned long *)(0x50007000 + 0x410)))
N#define SECPKEADMESS         (*((volatile unsigned long *)(0x50007000 + 0x414))) 
N#define SECSWRSTFLG          (*((volatile unsigned long *)(0x50007000 + 0x418)))
N#define SECHWRSTFLG          (*((volatile unsigned long *)(0x50007000 + 0x41C)))
N#define SECBUSY              (*((volatile unsigned long *)(0x50007000 + 0x420)))
N#define SECRBCLR             (*((volatile unsigned long *)(0x50007000 + 0x424)))
N#define SECREGPRT            (*((volatile unsigned long *)(0x50007000 + 0x428)))
N#define SECSWCES             (*((volatile unsigned long *)(0x50007000 + 0x42C)))
N#define SECAUTOCHK           (*((volatile unsigned long *)(0x50007000 + 0x430)))
N#define SECRNDSTOP           (*((volatile unsigned long *)(0x50007000 + 0x434)))
N#define SECTESTPRST          (*((volatile unsigned long *)(0x50007000 + 0x47C)))
N
N/********************************************************************************
N                             WDT Regsiter
N********************************************************************************/
N#define WDTLOAD              (*((volatile unsigned long *)(0x40000000 + 0x00 )))
N#define WDTVALUE             (*((volatile unsigned long *)(0x40000000 + 0x04 )))
N#define WDTCONTROL           (*((volatile unsigned long *)(0x40000000 + 0x08 )))
N#define WDTIS                (*((volatile unsigned long *)(0x40000000 + 0x0C )))
N
N/********************************************************************************
N                             TIMER Regsiter
N********************************************************************************/
N#define TIMER0LOAD           (*((volatile unsigned long *)(0x40000800 + 0x00 )))
N#define TIMER0VALUE          (*((volatile unsigned long *)(0x40000800 + 0x04 )))
N#define TIMER0CONTROL        (*((volatile unsigned long *)(0x40000800 + 0x08 )))
N#define TIMER0IS             (*((volatile unsigned long *)(0x40000800 + 0x0C )))
N#define TIMER1LOAD           (*((volatile unsigned long *)(0x40000800 + 0x20 )))
N#define TIMER1VALUE          (*((volatile unsigned long *)(0x40000800 + 0x24 )))
N#define TIMER1CONTROL        (*((volatile unsigned long *)(0x40000800 + 0x28 )))
N#define TIMER1IS             (*((volatile unsigned long *)(0x40000800 + 0x2C )))
N
N/********************************************************************************
N                             SCI Regsiter
N********************************************************************************/
N#define SCISBUF              (*((volatile unsigned long *)(0x40001000 + 0x00 )))
N#define SCISCON              (*((volatile unsigned long *)(0x40001000 + 0x04 )))
N#define SCISSR               (*((volatile unsigned long *)(0x40001000 + 0x08 )))
N#define SCISCNT              (*((volatile unsigned long *)(0x40001000 + 0x0C )))
N#define SCITXFCR             (*((volatile unsigned long *)(0x40001000 + 0x10 )))
N#define SCIRXFCR             (*((volatile unsigned long *)(0x40001000 + 0x14 )))
N#define SCITA1               (*((volatile unsigned long *)(0x40001000 + 0x18 )))
N#define SCIS60CON            (*((volatile unsigned long *)(0x40001000 + 0x1C )))
N
N/********************************************************************************
N                             SPI Regsiter
N********************************************************************************/
N#define SPICON               (*((volatile unsigned long *)(0x40001800 + 0x00 )))
N#define SPIDLEN              (*((volatile unsigned long *)(0x40001800 + 0x04 )))
N#define SPIST                (*((volatile unsigned long *)(0x40001800 + 0x08 )))
N#define SPIDIV               (*((volatile unsigned long *)(0x40001800 + 0x0C )))
N#define SPIIE                (*((volatile unsigned long *)(0x40001800 + 0x10 )))
N#define SPIIS                (*((volatile unsigned long *)(0x40001800 + 0x14 )))
N#define SPISTR               (*((volatile unsigned long *)(0x40001800 + 0x18 )))
N#define SPIDATA              (*((volatile unsigned long *)(0x40001800 + 0x40 )))
N
N/********************************************************************************
N                             RNG Regsiter
N********************************************************************************/
N#define RNG1XCFG             (*((volatile unsigned long *)(0x40002800 + 0x24 )))
N#define RNG1XCEN             (*((volatile unsigned long *)(0x40002800 + 0x28 )))
N#define RNG1XCSTR            (*((volatile unsigned long *)(0x40002800 + 0x2C )))
N#define RNG1STR              (*((volatile unsigned long *)(0x40002800 + 0x30 )))
N#define RNG1OUT              (*((volatile unsigned long *)(0x40002800 + 0x34 )))
N#define RTCNT0               (*((volatile unsigned long *)(0x40002800 + 0x38 )))
N#define RTCNT1               (*((volatile unsigned long *)(0x40002800 + 0x3C )))
N#define RTCNT2               (*((volatile unsigned long *)(0x40002800 + 0x40 )))
N#define RTCNT3               (*((volatile unsigned long *)(0x40002800 + 0x44 )))
N#define RTCNT4               (*((volatile unsigned long *)(0x40002800 + 0x48 )))
N#define RTCNT5               (*((volatile unsigned long *)(0x40002800 + 0x4C )))
N#define RTCNT6               (*((volatile unsigned long *)(0x40002800 + 0x50 )))
N#define RTCNT7               (*((volatile unsigned long *)(0x40002800 + 0x54 )))
N#define RTCNT8               (*((volatile unsigned long *)(0x40002800 + 0x58 )))
N#define RTCNT9               (*((volatile unsigned long *)(0x40002800 + 0x5C )))
N#define RTCNT10              (*((volatile unsigned long *)(0x40002800 + 0x60 )))
N#define RTCNT11              (*((volatile unsigned long *)(0x40002800 + 0x64 )))
N#define RTCNT12              (*((volatile unsigned long *)(0x40002800 + 0x68 )))
N#define RTCNT13              (*((volatile unsigned long *)(0x40002800 + 0x6C )))
N#define RTCNT14              (*((volatile unsigned long *)(0x40002800 + 0x70 )))
N#define RTCNT15              (*((volatile unsigned long *)(0x40002800 + 0x74 )))
N
N/********************************************************************************
N                             GPIO Regsiter
N********************************************************************************/
N#define GPIODATA             (*((volatile unsigned long *)(0x40003000 + 0x00 )))
N#define GPIODIR              (*((volatile unsigned long *)(0x40003000 + 0x04 )))
N#define GPIOIS               (*((volatile unsigned long *)(0x40003000 + 0x08 )))
N#define GPIOIBE              (*((volatile unsigned long *)(0x40003000 + 0x0c )))
N#define GPIOIEV              (*((volatile unsigned long *)(0x40003000 + 0x10 )))
N#define GPIOIE               (*((volatile unsigned long *)(0x40003000 + 0x14 )))
N#define GPIORIS              (*((volatile unsigned long *)(0x40003000 + 0x18 )))
N#define GPIOMIS              (*((volatile unsigned long *)(0x40003000 + 0x1c )))
N#define GPIOIC               (*((volatile unsigned long *)(0x40003000 + 0x20 )))
N
N/********************************************************************************
N                             SWP Regsiter
N********************************************************************************/
N#define SWPIT                (*((volatile unsigned long *)(0x40003800 + 0x00 )))
N#define SWPITMK              (*((volatile unsigned long *)(0x40003800 + 0x04 )))
N#define SWPITEN              (*((volatile unsigned long *)(0x40003800 + 0x08 )))
N#define SWPITENCLR           (*((volatile unsigned long *)(0x40003800 + 0x0C )))
N#define SWPCON               (*((volatile unsigned long *)(0x40003800 + 0x10 )))
N#define SWPCLT               (*((volatile unsigned long *)(0x40003800 + 0x14 )))
N#define SWPTFS               (*((volatile unsigned long *)(0x40003800 + 0x18 )))
N#define SWPRFS               (*((volatile unsigned long *)(0x40003800 + 0x1C )))
N#define SWPBFC               (*((volatile unsigned long *)(0x40003800 + 0x20 )))
N#define SWPBFS               (*((volatile unsigned long *)(0x40003800 + 0x24 )))
N#define SWPMTP               (*((volatile unsigned long *)(0x40003800 + 0x30 )))
N#define SWPMTC               (*((volatile unsigned long *)(0x40003800 + 0x34 )))
N#define SWPMOD               (*((volatile unsigned long *)(0x40003800 + 0x80 )))
N#define SWPPARA1             (*((volatile unsigned long *)(0x40003800 + 0x100 )))
N#define SWPPARA2             (*((volatile unsigned long *)(0x40003800 + 0x104 )))
N#define SWPPARA5             (*((volatile unsigned long *)(0x40003800 + 0x108 )))
N#define SWPSID               (*((volatile unsigned long *)(0x40003800 + 0x10C )))
N#define SWPSSR               (*((volatile unsigned long *)(0x40003800 + 0x180 )))
N#define SWPSTATE             (*((volatile unsigned long *)(0x40003800 + 0x184 )))
N#define SWPM1KL              (*((volatile unsigned long *)(0x40003800 + 0x1C0 )))
N#define SWPM1KM              (*((volatile unsigned long *)(0x40003800 + 0x1C4 )))
N#define SWPM1KH              (*((volatile unsigned long *)(0x40003800 + 0x1C8 )))
N#define SWPM1RNG             (*((volatile unsigned long *)(0x40003800 + 0x1CC )))
N#define SWPUID               (*((volatile unsigned long *)(0x40003800 + 0x1D0 )))
N#define SWPDBUF              (*((volatile unsigned long *)(0x40003800 + 0x300 )))
N#define SWPSDBUF             ((volatile unsigned long *)(0x40003800 + 0x304 ))
N
N/********************************************************************************
N                             PPB Regsiter
N********************************************************************************/
N
N#define ACTLR                 (*((volatile unsigned long *)( 0xE000E008	)))
N#define NVIC_ISER             (*((volatile unsigned long *)( 0xE000E100	)))
N#define NVIC_ICER             (*((volatile unsigned long *)( 0xE000E180	)))
N#define NVIC_ISPR             (*((volatile unsigned long *)( 0xE000E200	)))
N#define NVIC_ICPR             (*((volatile unsigned long *)( 0xE000E280	)))
N#define NVIC_IPR0             (*((volatile unsigned long *)( 0xE000E400	)))
N#define NVIC_IPR1             (*((volatile unsigned long *)( 0xE000E404	)))
N#define NVIC_IPR2             (*((volatile unsigned long *)( 0xE000E408	)))
N#define NVIC_IPR3             (*((volatile unsigned long *)( 0xE000E40C	)))
N#define NVIC_IPR4             (*((volatile unsigned long *)( 0xE000E410	)))
N#define NVIC_IPR5             (*((volatile unsigned long *)( 0xE000E414	)))
N#define NVIC_IPR6             (*((volatile unsigned long *)( 0xE000E418	)))
N#define NVIC_IPR7             (*((volatile unsigned long *)( 0xE000E41C	)))
N#define CPUID                 (*((volatile unsigned long *)( 0xE000ED00	)))
N#define ICSR                  (*((volatile unsigned long *)( 0xE000ED04	)))
N#define VTOR                  (*((volatile unsigned long *)( 0xE000ED08	)))
N#define AIRCR                 (*((volatile unsigned long *)( 0xE000ED0C	)))
N#define SCR                   (*((volatile unsigned long *)( 0xE000ED10	)))
N#define CCR                   (*((volatile unsigned long *)( 0xE000ED14	)))
N#define SHPR2                 (*((volatile unsigned long *)( 0xE000ED1C	)))
N#define SHPR3                 (*((volatile unsigned long *)( 0xE000ED20	)))
N#define MPU_TYPE              (*((volatile unsigned long *)( 0xE000ED90	)))
N#define MPU_CTRL              (*((volatile unsigned long *)( 0xE000ED94	)))
N#define MPU_RNR               (*((volatile unsigned long *)( 0xE000ED98	)))
N#define MPU_RBAR              (*((volatile unsigned long *)( 0xE000ED9C	)))
N#define MPU_RASR              (*((volatile unsigned long *)( 0xE000EDA0	)))
N#define SFCR                  (*((volatile unsigned long *)( 0xE000EF90	)))
N
N/********************************************************************************
N                             Interrupt Source
N********************************************************************************/
N#define     IRQ_TMR0                0
N#define     IRQ_TMR1                1
N#define     IRQ_WDT                 2
N#define     IRQ_NVMCTR              3
N#define     IRQ_NVMDE               4
N#define     IRQ_SECRST              5
N#define     IRQ_RNG1                7
N#define     IRQ_7816RST             8
N#define     IRQ_7816TX              9
N#define     IRQ_7816RX              10
N#define     IRQ_7816FIFO            11
N#define     IRQ_IFDET               12
N#define     IRQ_SWP                 13
N#define     IRQ_SPI                 14
N#define     IRQ_GPIOINT0            15
N
N#endif  /* End of __IO_CIU98M25_H */
L 17 "SRC\../inc/Declare.h" 2
N#include "SubFunc.h"
L 1 "SRC\../inc/SubFunc.h" 1
N/*****************************************************
N Copyright(C),CEC Huada Electronic Design Co.,Ltd.
N 
N Project name: 	SubFunc.h
N Author:    	
N Version:		
N Date:  		
N Description: 
N History:	
N******************************************************/
N#ifndef __SUBFUNC_H_
N#define __SUBFUNC_H_
N
N#define SET_REG_BIT(reg,bit) 			(reg |= (1 << (bit)))
N#define CLEAR_REG_BIT(reg,bit) 			(reg &= ~(1 << (bit)))
N
Nvoid PpsExchange(void);
Nvoid FLASH_CLEAR_HVPT(void);
Nvoid RF_Config(void);
Nvoid Set_Init_SYSCLK(void);
Nvoid GlobalPARA_Init(void);
N
N#define PPS_PPSS SCIAPDUBuf[0]
N#define PPS_PPS0 SCIAPDUBuf[1]
N#define PPS_PPS1 SCIAPDUBuf[2]
N#define PPS_PPS2 SCIAPDUBuf[3]
N#define PPS_PPS3 SCIAPDUBuf[4]
N#define PPS_PCK  SCIAPDUBuf[5]
N#define PPS_NUM 5
N
N#endif
N
L 18 "SRC\../inc/Declare.h" 2
N#include "APDU_7816.h"
L 1 "SRC\../inc/APDU_7816.h" 1
N/*****************************************************
N Copyright(C),CEC Huada Electronic Design Co.,Ltd.
N 
N Project name: 	APDU_7816.h
N Author:    	
N Version:		
N Date:  		
N Description: 
N History:	
N******************************************************/
N#ifndef _APDU_7816_H_
N#define _APDU_7816_H_
N
Nvoid SCIAPDU_Dispatch(void);
N
N#endif
L 19 "SRC\../inc/Declare.h" 2
N#include "APDU_SWP_CARD.h"
L 1 "SRC\../inc/APDU_SWP_CARD.h" 1
N/*****************************************************
N Copyright(C),CEC Huada Electronic Design Co.,Ltd.
N 
N Project name: 	APDU_SWP_CARD.h
N Author:    	
N Version:		
N Date:  		
N Description: 
N History:	
N******************************************************/
N#ifndef _APDU_SWP_CARD_H_
N#define _APDU_SWP_CARD_H_ 
N
Nvoid SWPAPDU_Dispatch(void);
Nvoid SWPAPDU_Dispatch_APDU_GATE(void);
N
N#endif
L 20 "SRC\../inc/Declare.h" 2
N#include "SCI.h"
L 1 "SRC\../inc/SCI.h" 1
N/*****************************************************
N Copyright(C),CEC Huada Electronic Design Co.,Ltd.
N 
N File name: 	SCI.h
N Author:    	
N Version:			
N Date:  			
N Description: 
N History:	
N
N******************************************************/
N#ifndef _SCI_H_
N#define _SCI_H_
N
N#define	SCI_APDUBufSize	260
N
Nvoid SCI_Send_ATR(void);
Nvoid SCI_DelayNETU(unsigned int nETU);
Nvoid SCI_RxStart(void);
Nvoid SCI_StartTx_INT(unsigned short index);
Nvoid SCI_StoreNBytes(void);
Nvoid SCI_WaitRx(unsigned char index);
Nvoid GVar_SCI_Init(void);
Nvoid HED_T0_SendByte(unsigned char byte);
Nvoid SCI_Init(void);
Nvoid SendINS(unsigned char ins);
Nvoid SCI_StopTx60(void);
N
Nextern volatile unsigned short G_SCIRecieveIndex;
Nextern volatile unsigned char G_SCIRecieveDone;
Nextern volatile unsigned short G_SCISendIndex;
Nextern unsigned char G_bSCILeSendDone;
Nextern unsigned int SCILeLength;
N
Nextern const unsigned char G_ATR[];
Nextern unsigned char SCIAPDUBuf[];
N
N#endif
L 21 "SRC\../inc/Declare.h" 2
N#include "TYPEDEF.h"
L 1 "SRC\../inc/TYPEDEF.h" 1
N/*****************************************************
N Copyright(C),CEC Huada Electronic Design Co.,Ltd.
N 
N File name: 	TYPEDEF.h
N Author:    	
N Version:			
N Date:  			
N Description: 
N History:	
N
N******************************************************/
N#ifndef __TYPEDEF_H_
N#define __TYPEDEF_H_                                  
N
N#ifndef false
N#define false       (0)
N#endif
N
N#ifndef true
N#define true        (1)
N#endif
N
N/* Type Definition */
N#define INT8U   unsigned char
N#define INT16U  unsigned short
N#define INT32U  unsigned int
N
Ntypedef     unsigned char   bool;
N
N#define BIT0    (1ul<<0)
N#define BIT1    (1ul<<1)
N#define BIT2    (1ul<<2)
N#define BIT3    (1ul<<3)
N#define BIT4    (1ul<<4)
N#define BIT5    (1ul<<5)
N#define BIT6    (1ul<<6)
N#define BIT7    (1ul<<7)
N#define BIT8    (1ul<<8)
N#define BIT9    (1ul<<9)
N#define BIT10   (1ul<<10)
N#define BIT11   (1ul<<11)
N#define BIT12   (1ul<<12)
N#define BIT13   (1ul<<13)
N#define BIT14   (1ul<<14)
N#define BIT15   (1ul<<15)
N#define BIT16   (1ul<<16)
N#define BIT17   (1ul<<17)
N#define BIT18   (1ul<<18)
N#define BIT19   (1ul<<19)
N#define BIT20   (1ul<<20)
N#define BIT21   (1ul<<21)
N#define BIT24   (1ul<<24)
N#define BIT26   (1ul<<26)
N#define BIT30   (1ul<<30)
N#define BIT31   (1ul<<31)  
N
N#define 	DEMO_SET_BIT(x,y)  		(x |= (0x01 <<y))    // 
N#define 	DEMO_CLR_BIT(x,y)  		(x &= (~(0x01 <<y))) // 
N#define 	DEMO_CHECK_BIT(x,y) 	(x & (0x01 <<y))    // 
N
N//define the function pointer structure for the APDU command
Ntypedef struct 
N{
N    INT8U ins;
X    unsigned char ins;
N    void (*func)(void);
N}COMMANDLIST;
N#endif
L 22 "SRC\../inc/Declare.h" 2
N#include "Interrupt.h"
L 1 "SRC\../inc/Interrupt.h" 1
N/*****************************************************
N Copyright(C),CEC Huada Electronic Design Co.,Ltd.
N 
N Project name: 	Interrupt.h
N Author:    	
N Version:		
N Date:  		
N Description: 
N History:	
N******************************************************/
N#ifndef _INTERRUPT_H_
N#define _INTERRUPT_H_
N
Nvoid SCIRST_HANDLER(void);
Nvoid SCIRx_HANDLER(void);
Nvoid SCITx_HANDLER(void);
N
Nextern unsigned short SW1SW2;
Nextern volatile unsigned char G_bATR_Done;
Nextern volatile unsigned char G_SCIRecieving;
N
N#endif
L 23 "SRC\../inc/Declare.h" 2
N#include "HCI_lib_API.h"
L 1 "SRC\../inc/HCI_lib_API.h" 1
N/*****************************************************
N Copyright(C),CEC Huada Electronic Design Co.,Ltd.
N 
N Project name: 	HCI_lib_API.h
N Author:    	
N Version:		
N Date:  		
N Description: 
N History:	
N                V1.0	2014-11-26	initial version
N                V1.1	2015-08-06	add two API, void HCI_APDU_Gate_Send(void)/unsigned int HCI_APDU_Gate_Send_WTX(void)
N******************************************************/
N#ifndef _HCI_LIB_API_H_
N#define _HCI_LIB_API_H_
N
Nvoid HCI_GVar_Init(void);
Nvoid SWP_Init(void);
Nunsigned int HCI_Init(unsigned char appMode, unsigned short RFType);
Nunsigned int HCI_RxManage(void);
Nvoid HCI_CardMode_Send(void);
Nvoid HCI_ReaderMode_Send(void);
Nvoid HCI_APDU_Gate_Send(void);
Nunsigned int HCI_Connectivity_Send (unsigned int type, unsigned char *para, unsigned int paraLen);
Nunsigned int HCI_End_Of_Operation (void);
Nunsigned int HCI_Mode_Switch (unsigned int mode);
Nunsigned int HCI_APDU_Gate_Send_WTX(void);
Nvoid SWPIO_Detect_Handler (void);
Nvoid SWP_Tansfers_Handler(void);
Nvoid HCI_RSTSyncID (void);
Nunsigned char HCI_SetPara_Send(void);
Nunsigned char HCI_GetPara_Send(void);
Nunsigned int SWP_APIVersion (void);
N
Nunsigned int HED_M1_InitBlock(unsigned int * piBlock0Data);
Nunsigned int HED_M1_ResetSector (unsigned int sectorID);
Nunsigned int HED_M1_PwReadBlock (unsigned int *piPwData, unsigned char cMifareBlock);
Nunsigned int HED_M1_PwWriteBlock (unsigned int *piPwData, unsigned char cMifareBlock);
N
Nextern volatile unsigned char	G_bPowerMode;
Nextern volatile unsigned char	G_bSHDLC_Status;
N
N#endif
L 24 "SRC\../inc/Declare.h" 2
N#include "HCI_lib_GVar.h"
L 1 "SRC\../inc/HCI_lib_GVar.h" 1
N/*****************************************************
N Copyright(C),CEC Huada Electronic Design Co.,Ltd.
N 
N Project name: 	HCI_lib_GVar.h
N Author:    	
N Version:		
N Date:  		
N Description: 
N History:
N                V1.0	2014-11-26	initial version 
N                V1.1	2015-08-06	add G_APDUGateBuf/G_APDUGateLen
N                V1.2  2016-05-30  add G_SYNC_PARA/G_CmptblCtrl
N******************************************************/
N#ifndef _HCI_LIB_GVAR_H_
N#define _HCI_LIB_GVAR_H_
N
N#define  G_uiccHCIConfig_Flash  ((configData *)HCIConfig_ADRESS)
N
N// #define SWP_PARA1 		 0x13F
N// #define SWP_PARA2 		 0x0B
N// #define SWP_PARA5 		 0x1A4
N
Nextern unsigned char G_SYNC_PARA;
Nextern unsigned char G_CmptblCtrl;
Nextern unsigned short G_triggerResult;
Nextern unsigned int G_AppOpenSta;
Nextern unsigned char G_bSWP_DetectStatus;
Nextern unsigned char G_bCardActivated;
Nextern unsigned char G_APDUBuf[];
Nextern unsigned short G_APDULen;
Nextern unsigned char G_HCIMode;
Nextern unsigned char G_bSWP_busy;
Nextern unsigned char G_bCLKSwitchValid;
N
Nextern unsigned char G_appMode;
Nextern unsigned short G_RFType;
Nextern unsigned char G_ReaderTimerOutInteger;
Nextern unsigned char G_bFstAPDU;
Nextern unsigned char G_SetParaBuf[];
Nextern unsigned char G_GetParaBuf[];
Nextern unsigned char G_bRFIndicator;
Nextern unsigned char G_bAPPSendType;
Nextern unsigned char G_GetRFType;
Nextern unsigned char G_APDUGateBuf[];
Nextern unsigned short G_APDUGateLen;
N//const
N//IDManagement Gate Registry
Nextern unsigned char pReg_ID_Gate_VerSW[];
Nextern unsigned char pReg_ID_Gate_VerHard[];
Nextern unsigned char pReg_ID_Gate_Vendor_Name[];
Nextern unsigned char pReg_ID_Gate_Model_ID[];
N//CLF TYPEA card RF Gate Registry
Nextern unsigned char aReg_CardRFTypeA_UID[]; 
Nextern unsigned char aReg_CardRFTypeA_SAK[]; 
Nextern unsigned char aReg_CardRFTypeA_ATQA[]; 
Nextern unsigned char aReg_CardRFTypeA_History[];
Nextern unsigned char aReg_CardRFTypeA_TB1[];
Nextern unsigned char aReg_CardRFTypeA_MAXDataRate[];
Nextern unsigned char aReg_CardRFTypeA_CID_SUPPORT[];
N//CLF TYPEA reader RF Gate Registry
Nextern unsigned char aReg_ReaderRFTypeA_MAXDataRate [];
N//CLF TYPEB card RF Gate Registry
Nextern unsigned char aReg_CardRFTypeB_AFI[]; 
Nextern unsigned char aReg_CardRFTypeB_ATQB[]; 
Nextern unsigned char aReg_CardRFTypeB_MAXDataRate[];
N
N//variable
N//CLF TYPEA reader RF Gate Registry
Nextern unsigned char aReg_ReaderRFTypeA_UID[];
Nextern unsigned char aReg_ReaderRFTypeA_SAK[];
Nextern unsigned char aReg_ReaderRFTypeA_ATQA[];  
Nextern unsigned char aReg_ReaderRFTypeA_History[];
Nextern unsigned char aReg_ReaderRFTypeA_TB1[];
N
Nextern unsigned int HCIConfig_ADRESS;
N
N/*variables below can be located in EEPROM, JAVA OS init and update*/
Nextern unsigned char G_cM1_Mode;
Nextern unsigned char G_cM1_PwAlgType;
N
N#endif
L 25 "SRC\../inc/Declare.h" 2
N#include "CIU98M25_API_LIB_STABILITY.h"
L 1 "SRC\../inc/CIU98M25_API_LIB_STABILITY.h" 1
N/*****************************************************
N Copyright(C),CEC Huada Electronic Design Co.,Ltd.
N 
N File name: CIU98M25_API_LIB_STABILITY.h
N Author:    	
N Version:       	
N Date:      	
N Description:   
N History:
N                V1.0	2014-11-26	initial version                
N******************************************************/
N#ifndef __CIU98M25_API_LIB_STABILITY_H_
N#define __CIU98M25_API_LIB_STABILITY_H_
N
Nvoid openWrSwitch(void);
Nvoid closeWrSwitch(void);
Nvoid chkWrSwitch(void);    
Nvoid setWrMode(unsigned int nvmMode);
N
N#endif   /* End of "__HED_ARM_LIB_H" */
L 26 "SRC\../inc/Declare.h" 2
N#include "CIU98M25_API_LIB_SHA_RNG.h"
L 1 "SRC\../inc/CIU98M25_API_LIB_SHA_RNG.h" 1
N/*****************************************************
N Copyright(C),CEC Huada Electronic Design Co.,Ltd.
N 
N File name: CIU98M25_API_LIB_SHA_RNG.h
N Author:    
N Version:
N Date:  
N Description:   CIU98M25 User API Function header file
N History:
N                V1.0	2014-11-26	initial version
N******************************************************/
N
N
N#ifndef __CIU98M25_API_LIB_SHA_RNG_H_
N#define __CIU98M25_API_LIB_SHA_RNG_H_
N
N/* API FUCTION DEFINE */
N/* Random */
Nvoid HED_GetRandom_Enhanced (unsigned char *RandomData,unsigned int DataLen);
Nvoid HED_GetRandom(unsigned char *RandomData,unsigned int DataLen);
N/* RNGCHECK */
Nunsigned int HED_RNG1Check(void);
Nunsigned int HED_PokerCheck(void);
N/* SHA160 */
Nvoid HED_SHA1_Init(unsigned int *v);
Nunsigned int HED_SHA1_Block (unsigned int * V, const unsigned int * DataValue, unsigned int DataLen);
N/* SHA256 */
Nvoid HED_SHA256_Init(unsigned int *v);
Nunsigned int HED_SHA256_Block (unsigned int * V, const unsigned int * DataValue, unsigned int DataLen);
N
N#endif   /* End of "__HED_ARM_LIB_H" */
L 27 "SRC\../inc/Declare.h" 2
N#include "CIU98M25_API_Base_NoNVM.h"
L 1 "SRC\../inc/CIU98M25_API_Base_NoNVM.h" 1
N/*****************************************************
N Copyright(C),CEC Huada Electronic Design Co.,Ltd.
N 
N File name: CIU98M25_API_Base_NoNVM.h
N Author:    
N Version:
N Date:  
N Description:   CIU98M25 User API Function header file
N History:
N                V1.0	2014-11-26	initial version
N******************************************************/
N
N
N#ifndef __CIU98M25_API_BASE_NONVM_H_
N#define __CIU98M25_API_BASE_NONVM_H_
N
N/* Change Frequency */
Ntypedef enum
N{
N    SYSCLK_AHB_36Mhz =  0x0, 
N    SYSCLK_AHB_18Mhz  =  0x1, 
N    SYSCLK_AHB_15Mhz  =  0x2, 
N    SYSCLK_AHB_6Mhz  =  0x6, 
N}SYS_FREQUENCY_DIVISOR;
N
Ntypedef enum
N{
N	APB_EQU_AHB = 0,
N	APB_HALF_AHB = 1,
N} APB_FREQUENCY_DIVISOR;
N
N/* API FUCTION DEFINE */
N/* 7816 Interface */
Nunsigned int HED_T0_SendNBytes(unsigned char * DataAddr, unsigned int DataLen);
Nvoid HED_T0_ReceiveNBytesRam(unsigned char * DataAddr, unsigned int DataLen); 
N/* CRC */
Nunsigned short HED_CRC16(unsigned short IV, unsigned int DataLen, unsigned char *DataBuf, unsigned char type);
N/* Chip ID */
Nvoid HED_GetChipId(unsigned char *ChipId);
N/* Factory Code */
Nvoid HED_GetFactoryCode(unsigned char * FactoryCode);
N/* Change Frequency */
Nvoid HED_ChangeSYSFreq(SYS_FREQUENCY_DIVISOR SysDiv, APB_FREQUENCY_DIVISOR APBDiv); 
N/* Set standby Mode */
Nvoid HED_SetToStandby(void);
N/* SPI-Master */
Nvoid HED_SPIM_SendNBytes(unsigned char *DataAddr, unsigned int DataLen);
Nvoid HED_SPIM_ReceiveNBytesRam(unsigned char *DataAddr, unsigned int DataLen);
N/* SPI-Slave */
Nvoid HED_SPIS_SendNBytes(unsigned char *DataAddr, unsigned int DataLen);
Nunsigned char HED_SPIS_ReceiveNBytesRam(unsigned char *DataAddr, unsigned int DataLen);
N
N#endif   /* End of "__HED_ARM_LIB_H" */
L 28 "SRC\../inc/Declare.h" 2
N#include "CIU98M25_API_NVM_STABILITY.h"
L 1 "SRC\../inc/CIU98M25_API_NVM_STABILITY.h" 1
N/*****************************************************
N Copyright(C),CEC Huada Electronic Design Co.,Ltd.
N 
N File name: CIU98M25_API_NVM_STABILITY.h
N Author:    	
N Version:       	
N Date:      	
N Description:   
N History:
N                V1.0	2014-11-26	initial version                
N******************************************************/
N#ifndef __CIU98M25_API_NVM_STABILITY_H_
N#define __CIU98M25_API_NVM_STABILITY_H_
N
Nunsigned int HED_FlashPageInit_St(unsigned int DestAddr);
Nunsigned int HED_FlashErWrPage_St(unsigned int DestAddr,unsigned int * SrcAddr);
Nvoid HED_FlashPageBufClr (void);
N
N#endif   /* End of "__HED_ARM_LIB_H" */
L 29 "SRC\../inc/Declare.h" 2
N#include "CIU98M25_ALG_LIB.h"
L 1 "SRC\../inc/CIU98M25_ALG_LIB.h" 1
N/*******************************************************************************
N Copyright(C),CEC Huada Electronic Design Co.,Ltd.
N File name:     CIU98M25_ALG_LIB.h
N Author:        Wangyun
N Version:       V1.0 
N Date:          2014-12-17
N Description:  
N History:       
N                V1.0	2014-12-17	initial version
N*******************************************************************************/
N#ifndef __CIU98M25_ALG_LIB_H__
N#define __CIU98M25_ALG_LIB_H__
N
Ntypedef struct
N{
N	const unsigned int	*pE;
N	unsigned int		*pN;
N	unsigned int		*pP;
N	unsigned int		*pQ;
N	unsigned int		*pDp;
N	unsigned int		*pDq;
N	unsigned int		*pQInv;
N	unsigned int		*pD;
N	unsigned int		*pPreKey;
N	unsigned int		*pDataIn;
N	unsigned int		*pDataOut;
N	unsigned int		operMode;
N	unsigned int		len;
N}   RSA_Info;
Ntypedef struct
N{
N	const	unsigned int    *pE;
N			unsigned int    *pN;
N	const	unsigned int    *pP;
N	const	unsigned int    *pQ;
N	const	unsigned int    *pDp;
N	const	unsigned int    *pDq;
N	const	unsigned int    *pQInv;
N	const	unsigned int    *pD;
N			unsigned int    *pPreKey;  
N	const	unsigned int    *pDataIn;
N			unsigned int    *pDataOut;
N	const	unsigned int    operMode;
N	const	unsigned int    len;
N}   RSA_Info_Const;
N
Ntypedef struct 
N{
N	unsigned int *pR2n;
N	unsigned int *pMcn;
N	unsigned int *pR2p;
N	unsigned int *pMcp;
N	unsigned int *pR2q;
N	unsigned int *pMcq;
N} RSA_PreKey_Info;
N
Ntypedef struct 
N{
N	unsigned int *iDataPtr;
N	unsigned int DataLen;
N	unsigned int *iKeyPtr;
N	unsigned int *IVPtr;
N	unsigned int *oDataPtr;
N	unsigned char Type;
N}SM1_Parameters, SM4_Parameters, SSF33_Parameters;
N
Ntypedef struct                      
N{                                   
N    const unsigned char  *iDataPtr;  
N    unsigned char        *oDataPtr;  
N    const unsigned int   *rndPtr;    
N    unsigned int         *priKeyPtr; 
N    unsigned int         *pubKeyPtr; 
N    unsigned int          iEccSel;   
N} SM2_Parameters;  
N
Ntypedef struct                          
N{                                       
N    const unsigned char *AID;           
N    const unsigned char *BID;           
N    const unsigned int  *PublicKey;     
N    const unsigned int  *PrivateKey;    
N    const unsigned int  *BPublicKey;    
N    const unsigned int  *TempPrivateKey;
N    const unsigned int  *TempPubKeyX;   
N    const unsigned int  *BTempPubKey;   
N    unsigned int         oLen;          
N    unsigned int         DataType;      
N    unsigned int         iEccSel;       
N} SM2KeyExch_Parameters;                
N
Nunsigned int HED_RSA2048_GenKey(RSA_Info *keys);
Nunsigned int HED_RSA2048_Complete(RSA_Info *keys);
Nunsigned int HED_RSA2048_PubOpt(RSA_Info *keys);
Nunsigned int HED_RSA2048_PriOpt(RSA_Info *keys);
Nunsigned int HED_RSA2048_CalE (unsigned int *e, unsigned int *p, unsigned int *dp, unsigned int len);
N
N
Nunsigned int HED_SM2GenKey(SM2_Parameters *SM2_Param);                                                                     
Nunsigned int HED_SM2GetZ(const unsigned char *AID, const unsigned int *PublicKey, unsigned int *Za, unsigned int iEccSel); 
Nunsigned int HED_SM2Sign(SM2_Parameters *SM2_Param);                                                                       
Nunsigned int HED_SM2Verify(SM2_Parameters *SM2_Param);                                                                     
Nunsigned int HED_SM2Encrypt(SM2_Parameters *SM2_Param, unsigned int iLen);                                                 
Nunsigned int HED_SM2Decrypt(SM2_Parameters *SM2_Param, unsigned int iLen);                                                 
N//need input random                                                                                                        
Nunsigned int HED_SM2GenKey2(SM2_Parameters *SM2_Param);                                                                    
Nunsigned int HED_SM2Sign2(SM2_Parameters *SM2_Param);                                                                      
Nunsigned int HED_SM2Encrypt2(SM2_Parameters *SM2_Param, unsigned int iLen);                                                
Nunsigned int HED_SM2KeyExchange(const SM2KeyExch_Parameters *SM2KeyExch_Para, unsigned char *oDataPtr);                    
Nvoid HED_SM3Initial(unsigned int *tmpV);                                                                                   
Nunsigned int HED_SM3Block(unsigned int *tmpV,const unsigned int *DataValue, unsigned int DataLen);                               
N
N
Nunsigned int HED_SM1Block (SM1_Parameters * SM1_Param);
Nunsigned int HED_SM4Block (SM4_Parameters * SM4_Param);
Nunsigned int HED_SSF33Block (SSF33_Parameters * SSF33_Param);
N
Nunsigned int HED_HEFlash_Init(void);
Nunsigned int HED_HEFlashEWPage(unsigned int FlashAddr, unsigned int * DataBuf);
Nunsigned int HED_HEFlashMapReset(void);
Nunsigned char HED_GetAPIVersion(void);
N
N#endif
L 30 "SRC\../inc/Declare.h" 2
N#include "CIU98M25_API_LIB_3DES.h"
L 1 "SRC\../inc/CIU98M25_API_LIB_3DES.h" 1
N/*****************************************************
N Copyright(C),CEC Huada Electronic Design Co.,Ltd.
N 
N File name: CIU98M25_API_LIB_3DES.h
N Author:    	
N Version:       	
N Date:      	
N Description:   
N History:
N                
N******************************************************/
N
N
N#ifndef __CIU98M25_API_LIB_3DES_H_
N#define __CIU98M25_API_LIB_3DES_H_
N
Ntypedef struct 
N{
N	unsigned int *iDataPtr;
N	unsigned int DataLen;
N	unsigned int *iKeyPtr;
N	unsigned int *IVPtr;
N	unsigned int *oDataPtr;
N	unsigned char Type;
N}DES3_Parameters;
N
Nunsigned int HED_DES3Block(DES3_Parameters * DES3_Param);
N
N#endif   /* End of "__HED_ARM_LIB_H" */
L 31 "SRC\../inc/Declare.h" 2
N#include "CIU98M25_API_LIB_DES.h"
L 1 "SRC\../inc/CIU98M25_API_LIB_DES.h" 1
N/*****************************************************
N Copyright(C),CEC Huada Electronic Design Co.,Ltd.
N 
N File name: CIU98M25_API_LIB_DES.h
N Author:    	
N Version:       	
N Date:      	
N Description:   
N History:
N                
N******************************************************/
N
N
N#ifndef __CIU98M25_API_LIB_DES_H_
N#define __CIU98M25_API_LIB_DES_H_
N
Ntypedef struct 
N{
N	unsigned int *iDataPtr;
N	unsigned int DataLen;
N	unsigned int *iKeyPtr;
N	unsigned int *IVPtr;
N	unsigned int *oDataPtr;
N	unsigned char Type;
N}DES_Parameters;
N
Nunsigned int HED_DESBlock(DES_Parameters * DES3_Param);
N
N#endif   /* End of "__HED_ARM_LIB_H" */
L 32 "SRC\../inc/Declare.h" 2
N#include "CIU98M25_API_LIB_AES.h"
L 1 "SRC\../inc/CIU98M25_API_LIB_AES.h" 1
N/*****************************************************
N Copyright(C),CEC Huada Electronic Design Co.,Ltd.
N 
N File name: CIU98M25_API_LIB_AES.h
N Author:    	
N Version:       	
N Date:      	
N Description:   
N History:
N                
N******************************************************/
N
N
N#ifndef __CIU98M25_API_LIB_AES_H_
N#define __CIU98M25_API_LIB_AES_H_
N
Ntypedef struct 
N{
N	unsigned int *iDataPtr;
N	unsigned int DataLen;
N	unsigned int *iKeyPtr;
N	unsigned int *IVPtr;
N	unsigned int *oDataPtr;
N	unsigned char Type;
N}AES_Parameters;
N
Nunsigned int HED_AESBlock (AES_Parameters * AES_Param);
N
N#endif   /* End of "__HED_ARM_LIB_H" */
L 33 "SRC\../inc/Declare.h" 2
N
N#endif
L 12 "SRC\SubFunc.c" 2
N
N#define         SFR_InitValue_Buffer_FlashLocation   (100*1024)//demo for user,cos can modify this address
N
N#define         SYSVR12PB_InitValue             0x0
N#define         SYSNVMVR12PB_InitValue          0x0
N#define         SYSVR18PB_InitValue             0x020102
N
N
N//this buffer can be abmodified by APDU in COS design
Nconst unsigned int SFR_InitValue_Buffer[3] __at(SFR_InitValue_Buffer_FlashLocation) = {SYSVR12PB_InitValue,SYSNVMVR12PB_InitValue,SYSVR18PB_InitValue};
Xconst unsigned int SFR_InitValue_Buffer[3] __attribute__ ((at((100*1024)))) = {0x0,0x0,0x020102};
N
N/****************************************************************************
N  Function:      PpsExchange
N  Description:    
N  Input:           
N  Output:         
N  Return:        
N  Others:                            
N****************************************************************************/
Nvoid PpsExchange(void)
N{
N	
N	register INT32U len,pck;
X	register unsigned int len,pck;
N	register INT32U i;
X	register unsigned int i;
N
N	PPS_PPSS = 0xff;
X	SCIAPDUBuf[0] = 0xff;
N	len = 1; 
N	for (i = 4; i<7; i++)
N	{
N		if (((PPS_PPS0 >> i) & 1) == 1)
X		if (((SCIAPDUBuf[1] >> i) & 1) == 1)
N			len++;
N	}
N	
N	while(G_SCIRecieveIndex != (len+2));//wait pps data all received
N
N	pck = 0x00;
N	for (i = 0; i<(len+2); i++)
N	{
N		pck = pck ^ SCIAPDUBuf[i];
N	}
N	if (pck == 0)
N	{
N		SCI_DelayNETU(4);
N		if ((PPS_PPS0 & 0x9F) == 0x10) 
X		if ((SCIAPDUBuf[1] & 0x9F) == 0x10) 
N		{
N			/* find FD */
N            if (PPS_PPS1 == 0x96)
X            if (SCIAPDUBuf[2] == 0x96)
N			{
N				/* send pps response */
N				PPS_PPS0 = 0x10;
X				SCIAPDUBuf[1] = 0x10;
N				SCIAPDUBuf[3] = 0x79;
N				HED_T0_SendByte(PPS_PPSS);
X				HED_T0_SendByte(SCIAPDUBuf[0]);
N				HED_T0_SendByte(PPS_PPS0);
X				HED_T0_SendByte(SCIAPDUBuf[1]);
N				HED_T0_SendByte(PPS_PPS1);
X				HED_T0_SendByte(SCIAPDUBuf[2]);
N				HED_T0_SendByte(PPS_PPS2);
X				HED_T0_SendByte(SCIAPDUBuf[3]);
N        SCITA1 = 0x96;               
X        (*((volatile unsigned long *)(0x40001000 + 0x18 ))) = 0x96;               
N				return;
N			}            
N		}
N		/* send pps err response */
N		HED_T0_SendByte(0xFF);
N		HED_T0_SendByte(0x00);
N		HED_T0_SendByte(0xFF);
N	}
N	else
N	{
N		/*means pps pck is err ,do nothing */
N	}
N}
N/****************************************************************************
N  Function:      RF_Config
N  Description:    
N  Input:           
N  Output:         
N  Return:        
N  Others:                            
N****************************************************************************/
Nvoid RF_Config(void)
N{
N	G_APDULen = 0;//0 bytes received of HCI layer
N	G_triggerResult = 0xf0;//trigger result init
N	G_HCIMode = 0;//default mode is card emulation 
N	G_AppOpenSta = 0;
N	G_appMode = 0x0F;//APDUGate/card /reader /connectivity
N	G_RFType = 0x0303;//card typeA & card typeB & reader typeA & reader typeB
N	G_ReaderTimerOutInteger = 0x18;
N    G_bFstAPDU = 0;
N    G_bRFIndicator = 0;
N    G_bAPPSendType = 1;
N    G_GetRFType = 0;   	
N}
N
N/****************************************************************************
N  Function:      UID_Init
N  Description:    
N  Input:           
N  Output:         
N  Return:        
N  Others:                            
N****************************************************************************/
Nvoid UID_Init(void)
N{
N    #define FACTORY_CODE_ADDR        0x1FFFFE00
N    #define FACTORY_UID_OFFSET       0x20
N    
N    aReg_CardRFTypeA_UID[0] = 0x04;//UID Length
N    aReg_CardRFTypeA_UID[1] = *((unsigned char *)(FACTORY_CODE_ADDR+FACTORY_UID_OFFSET+0));//UID0
X    aReg_CardRFTypeA_UID[1] = *((unsigned char *)(0x1FFFFE00+0x20+0));
N    aReg_CardRFTypeA_UID[2] = *((unsigned char *)(FACTORY_CODE_ADDR+FACTORY_UID_OFFSET+1));//UID1
X    aReg_CardRFTypeA_UID[2] = *((unsigned char *)(0x1FFFFE00+0x20+1));
N    aReg_CardRFTypeA_UID[3] = *((unsigned char *)(FACTORY_CODE_ADDR+FACTORY_UID_OFFSET+2));//UID2
X    aReg_CardRFTypeA_UID[3] = *((unsigned char *)(0x1FFFFE00+0x20+2));
N    aReg_CardRFTypeA_UID[4] = *((unsigned char *)(FACTORY_CODE_ADDR+FACTORY_UID_OFFSET+3));//UID3
X    aReg_CardRFTypeA_UID[4] = *((unsigned char *)(0x1FFFFE00+0x20+3));
N}
N/****************************************************************************
N  Function:      GlobalPARA_Init
N  Description:    
N  Input:           
N  Output:         
N  Return:        
N  Others:                            
N****************************************************************************/
Nvoid GlobalPARA_Init(void)
N{
N    G_SYNC_PARA = 0x01;
N    G_CmptblCtrl = 0x00;
N    
N    SYSVR12PB = SFR_InitValue_Buffer[0];//modify default value of SFR here
X    (*((volatile unsigned long *)(0x50007000 + 0x294))) = SFR_InitValue_Buffer[0];
N    SYSNVMVR12PB = SFR_InitValue_Buffer[1];//modify default value of SFR here
X    (*((volatile unsigned long *)(0x50007000 + 0x298))) = SFR_InitValue_Buffer[1];
N    SYSVR18PB = SFR_InitValue_Buffer[2];//modify default value of SFR here
X    (*((volatile unsigned long *)(0x50007000 + 0x29C))) = SFR_InitValue_Buffer[2];
N}
N
